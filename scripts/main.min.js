/**!
 * AngularJS file upload directives and services. Supoorts: file upload/drop/paste, resume, cancel/abort,
 * progress, resize, thumbnail, preview, validation and CORS
 * @author  Danial  <danial.farid@gmail.com>
 * @version 12.2.13
 */

if (window.XMLHttpRequest && !(window.FileAPI && FileAPI.shouldLoad)) {
  window.XMLHttpRequest.prototype.setRequestHeader = (function (orig) {
    return function (header, value) {
      if (header === '__setXHR_') {
        var val = value(this);
        // fix for angular < 1.2.0
        if (val instanceof Function) {
          val(this);
        }
      } else {
        orig.apply(this, arguments);
      }
    };
  })(window.XMLHttpRequest.prototype.setRequestHeader);
}

var ngFileUpload = angular.module('ngFileUpload', []);

ngFileUpload.version = '12.2.13';

ngFileUpload.service('UploadBase', ['$http', '$q', '$timeout', function ($http, $q, $timeout) {
  var upload = this;
  upload.promisesCount = 0;

  this.isResumeSupported = function () {
    return window.Blob && window.Blob.prototype.slice;
  };

  var resumeSupported = this.isResumeSupported();

  function sendHttp(config) {
    config.method = config.method || 'POST';
    config.headers = config.headers || {};

    var deferred = config._deferred = config._deferred || $q.defer();
    var promise = deferred.promise;

    function notifyProgress(e) {
      if (deferred.notify) {
        deferred.notify(e);
      }
      if (promise.progressFunc) {
        $timeout(function () {
          promise.progressFunc(e);
        });
      }
    }

    function getNotifyEvent(n) {
      if (config._start != null && resumeSupported) {
        return {
          loaded: n.loaded + config._start,
          total: (config._file && config._file.size) || n.total,
          type: n.type, config: config,
          lengthComputable: true, target: n.target
        };
      } else {
        return n;
      }
    }

    if (!config.disableProgress) {
      config.headers.__setXHR_ = function () {
        return function (xhr) {
          if (!xhr || !xhr.upload || !xhr.upload.addEventListener) return;
          config.__XHR = xhr;
          if (config.xhrFn) config.xhrFn(xhr);
          xhr.upload.addEventListener('progress', function (e) {
            e.config = config;
            notifyProgress(getNotifyEvent(e));
          }, false);
          //fix for firefox not firing upload progress end, also IE8-9
          xhr.upload.addEventListener('load', function (e) {
            if (e.lengthComputable) {
              e.config = config;
              notifyProgress(getNotifyEvent(e));
            }
          }, false);
        };
      };
    }

    function uploadWithAngular() {
      $http(config).then(function (r) {
          if (resumeSupported && config._chunkSize && !config._finished && config._file) {
            var fileSize = config._file && config._file.size || 0;
            notifyProgress({
                loaded: Math.min(config._end, fileSize),
                total: fileSize,
                config: config,
                type: 'progress'
              }
            );
            upload.upload(config, true);
          } else {
            if (config._finished) delete config._finished;
            deferred.resolve(r);
          }
        }, function (e) {
          deferred.reject(e);
        }, function (n) {
          deferred.notify(n);
        }
      );
    }

    if (!resumeSupported) {
      uploadWithAngular();
    } else if (config._chunkSize && config._end && !config._finished) {
      config._start = config._end;
      config._end += config._chunkSize;
      uploadWithAngular();
    } else if (config.resumeSizeUrl) {
      $http.get(config.resumeSizeUrl).then(function (resp) {
        if (config.resumeSizeResponseReader) {
          config._start = config.resumeSizeResponseReader(resp.data);
        } else {
          config._start = parseInt((resp.data.size == null ? resp.data : resp.data.size).toString());
        }
        if (config._chunkSize) {
          config._end = config._start + config._chunkSize;
        }
        uploadWithAngular();
      }, function (e) {
        throw e;
      });
    } else if (config.resumeSize) {
      config.resumeSize().then(function (size) {
        config._start = size;
        if (config._chunkSize) {
          config._end = config._start + config._chunkSize;
        }
        uploadWithAngular();
      }, function (e) {
        throw e;
      });
    } else {
      if (config._chunkSize) {
        config._start = 0;
        config._end = config._start + config._chunkSize;
      }
      uploadWithAngular();
    }


    promise.success = function (fn) {
      promise.then(function (response) {
        fn(response.data, response.status, response.headers, config);
      });
      return promise;
    };

    promise.error = function (fn) {
      promise.then(null, function (response) {
        fn(response.data, response.status, response.headers, config);
      });
      return promise;
    };

    promise.progress = function (fn) {
      promise.progressFunc = fn;
      promise.then(null, null, function (n) {
        fn(n);
      });
      return promise;
    };
    promise.abort = promise.pause = function () {
      if (config.__XHR) {
        $timeout(function () {
          config.__XHR.abort();
        });
      }
      return promise;
    };
    promise.xhr = function (fn) {
      config.xhrFn = (function (origXhrFn) {
        return function () {
          if (origXhrFn) origXhrFn.apply(promise, arguments);
          fn.apply(promise, arguments);
        };
      })(config.xhrFn);
      return promise;
    };

    upload.promisesCount++;
    if (promise['finally'] && promise['finally'] instanceof Function) {
      promise['finally'](function () {
        upload.promisesCount--;
      });
    }
    return promise;
  }

  this.isUploadInProgress = function () {
    return upload.promisesCount > 0;
  };

  this.rename = function (file, name) {
    file.ngfName = name;
    return file;
  };

  this.jsonBlob = function (val) {
    if (val != null && !angular.isString(val)) {
      val = JSON.stringify(val);
    }
    var blob = new window.Blob([val], {type: 'application/json'});
    blob._ngfBlob = true;
    return blob;
  };

  this.json = function (val) {
    return angular.toJson(val);
  };

  function copy(obj) {
    var clone = {};
    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        clone[key] = obj[key];
      }
    }
    return clone;
  }

  this.isFile = function (file) {
    return file != null && (file instanceof window.Blob || (file.flashId && file.name && file.size));
  };

  this.upload = function (config, internal) {
    function toResumeFile(file, formData) {
      if (file._ngfBlob) return file;
      config._file = config._file || file;
      if (config._start != null && resumeSupported) {
        if (config._end && config._end >= file.size) {
          config._finished = true;
          config._end = file.size;
        }
        var slice = file.slice(config._start, config._end || file.size);
        slice.name = file.name;
        slice.ngfName = file.ngfName;
        if (config._chunkSize) {
          formData.append('_chunkSize', config._chunkSize);
          formData.append('_currentChunkSize', config._end - config._start);
          formData.append('_chunkNumber', Math.floor(config._start / config._chunkSize));
          formData.append('_totalSize', config._file.size);
        }
        return slice;
      }
      return file;
    }

    function addFieldToFormData(formData, val, key) {
      if (val !== undefined) {
        if (angular.isDate(val)) {
          val = val.toISOString();
        }
        if (angular.isString(val)) {
          formData.append(key, val);
        } else if (upload.isFile(val)) {
          var file = toResumeFile(val, formData);
          var split = key.split(',');
          if (split[1]) {
            file.ngfName = split[1].replace(/^\s+|\s+$/g, '');
            key = split[0];
          }
          config._fileKey = config._fileKey || key;
          formData.append(key, file, file.ngfName || file.name);
        } else {
          if (angular.isObject(val)) {
            if (val.$$ngfCircularDetection) throw 'ngFileUpload: Circular reference in config.data. Make sure specified data for Upload.upload() has no circular reference: ' + key;

            val.$$ngfCircularDetection = true;
            try {
              for (var k in val) {
                if (val.hasOwnProperty(k) && k !== '$$ngfCircularDetection') {
                  var objectKey = config.objectKey == null ? '[i]' : config.objectKey;
                  if (val.length && parseInt(k) > -1) {
                    objectKey = config.arrayKey == null ? objectKey : config.arrayKey;
                  }
                  addFieldToFormData(formData, val[k], key + objectKey.replace(/[ik]/g, k));
                }
              }
            } finally {
              delete val.$$ngfCircularDetection;
            }
          } else {
            formData.append(key, val);
          }
        }
      }
    }

    function digestConfig() {
      config._chunkSize = upload.translateScalars(config.resumeChunkSize);
      config._chunkSize = config._chunkSize ? parseInt(config._chunkSize.toString()) : null;

      config.headers = config.headers || {};
      config.headers['Content-Type'] = undefined;
      config.transformRequest = config.transformRequest ?
        (angular.isArray(config.transformRequest) ?
          config.transformRequest : [config.transformRequest]) : [];
      config.transformRequest.push(function (data) {
        var formData = new window.FormData(), key;
        data = data || config.fields || {};
        if (config.file) {
          data.file = config.file;
        }
        for (key in data) {
          if (data.hasOwnProperty(key)) {
            var val = data[key];
            if (config.formDataAppender) {
              config.formDataAppender(formData, key, val);
            } else {
              addFieldToFormData(formData, val, key);
            }
          }
        }

        return formData;
      });
    }

    if (!internal) config = copy(config);
    if (!config._isDigested) {
      config._isDigested = true;
      digestConfig();
    }

    return sendHttp(config);
  };

  this.http = function (config) {
    config = copy(config);
    config.transformRequest = config.transformRequest || function (data) {
        if ((window.ArrayBuffer && data instanceof window.ArrayBuffer) || data instanceof window.Blob) {
          return data;
        }
        return $http.defaults.transformRequest[0].apply(this, arguments);
      };
    config._chunkSize = upload.translateScalars(config.resumeChunkSize);
    config._chunkSize = config._chunkSize ? parseInt(config._chunkSize.toString()) : null;

    return sendHttp(config);
  };

  this.translateScalars = function (str) {
    if (angular.isString(str)) {
      if (str.search(/kb/i) === str.length - 2) {
        return parseFloat(str.substring(0, str.length - 2) * 1024);
      } else if (str.search(/mb/i) === str.length - 2) {
        return parseFloat(str.substring(0, str.length - 2) * 1048576);
      } else if (str.search(/gb/i) === str.length - 2) {
        return parseFloat(str.substring(0, str.length - 2) * 1073741824);
      } else if (str.search(/b/i) === str.length - 1) {
        return parseFloat(str.substring(0, str.length - 1));
      } else if (str.search(/s/i) === str.length - 1) {
        return parseFloat(str.substring(0, str.length - 1));
      } else if (str.search(/m/i) === str.length - 1) {
        return parseFloat(str.substring(0, str.length - 1) * 60);
      } else if (str.search(/h/i) === str.length - 1) {
        return parseFloat(str.substring(0, str.length - 1) * 3600);
      }
    }
    return str;
  };

  this.urlToBlob = function(url) {
    var defer = $q.defer();
    $http({url: url, method: 'get', responseType: 'arraybuffer'}).then(function (resp) {
      var arrayBufferView = new Uint8Array(resp.data);
      var type = resp.headers('content-type') || 'image/WebP';
      var blob = new window.Blob([arrayBufferView], {type: type});
      var matches = url.match(/.*\/(.+?)(\?.*)?$/);
      if (matches.length > 1) {
        blob.name = matches[1];
      }
      defer.resolve(blob);
    }, function (e) {
      defer.reject(e);
    });
    return defer.promise;
  };

  this.setDefaults = function (defaults) {
    this.defaults = defaults || {};
  };

  this.defaults = {};
  this.version = ngFileUpload.version;
}

]);

ngFileUpload.service('Upload', ['$parse', '$timeout', '$compile', '$q', 'UploadExif', function ($parse, $timeout, $compile, $q, UploadExif) {
  var upload = UploadExif;
  upload.getAttrWithDefaults = function (attr, name) {
    if (attr[name] != null) return attr[name];
    var def = upload.defaults[name];
    return (def == null ? def : (angular.isString(def) ? def : JSON.stringify(def)));
  };

  upload.attrGetter = function (name, attr, scope, params) {
    var attrVal = this.getAttrWithDefaults(attr, name);
    if (scope) {
      try {
        if (params) {
          return $parse(attrVal)(scope, params);
        } else {
          return $parse(attrVal)(scope);
        }
      } catch (e) {
        // hangle string value without single qoute
        if (name.search(/min|max|pattern/i)) {
          return attrVal;
        } else {
          throw e;
        }
      }
    } else {
      return attrVal;
    }
  };

  upload.shouldUpdateOn = function (type, attr, scope) {
    var modelOptions = upload.attrGetter('ngfModelOptions', attr, scope);
    if (modelOptions && modelOptions.updateOn) {
      return modelOptions.updateOn.split(' ').indexOf(type) > -1;
    }
    return true;
  };

  upload.emptyPromise = function () {
    var d = $q.defer();
    var args = arguments;
    $timeout(function () {
      d.resolve.apply(d, args);
    });
    return d.promise;
  };

  upload.rejectPromise = function () {
    var d = $q.defer();
    var args = arguments;
    $timeout(function () {
      d.reject.apply(d, args);
    });
    return d.promise;
  };

  upload.happyPromise = function (promise, data) {
    var d = $q.defer();
    promise.then(function (result) {
      d.resolve(result);
    }, function (error) {
      $timeout(function () {
        throw error;
      });
      d.resolve(data);
    });
    return d.promise;
  };

  function applyExifRotations(files, attr, scope) {
    var promises = [upload.emptyPromise()];
    angular.forEach(files, function (f, i) {
      if (f.type.indexOf('image/jpeg') === 0 && upload.attrGetter('ngfFixOrientation', attr, scope, {$file: f})) {
        promises.push(upload.happyPromise(upload.applyExifRotation(f), f).then(function (fixedFile) {
          files.splice(i, 1, fixedFile);
        }));
      }
    });
    return $q.all(promises);
  }

  function resizeFile(files, attr, scope, ngModel) {
    var resizeVal = upload.attrGetter('ngfResize', attr, scope);
    if (!resizeVal || !upload.isResizeSupported() || !files.length) return upload.emptyPromise();
    if (resizeVal instanceof Function) {
      var defer = $q.defer();
      return resizeVal(files).then(function (p) {
        resizeWithParams(p, files, attr, scope, ngModel).then(function (r) {
          defer.resolve(r);
        }, function (e) {
          defer.reject(e);
        });
      }, function (e) {
        defer.reject(e);
      });
    } else {
      return resizeWithParams(resizeVal, files, attr, scope, ngModel);
    }
  }

  function resizeWithParams(params, files, attr, scope, ngModel) {
    var promises = [upload.emptyPromise()];

    function handleFile(f, i) {
      if (f.type.indexOf('image') === 0) {
        if (params.pattern && !upload.validatePattern(f, params.pattern)) return;
        params.resizeIf = function (width, height) {
          return upload.attrGetter('ngfResizeIf', attr, scope,
            {$width: width, $height: height, $file: f});
        };
        var promise = upload.resize(f, params);
        promises.push(promise);
        promise.then(function (resizedFile) {
          files.splice(i, 1, resizedFile);
        }, function (e) {
          f.$error = 'resize';
          (f.$errorMessages = (f.$errorMessages || {})).resize = true;
          f.$errorParam = (e ? (e.message ? e.message : e) + ': ' : '') + (f && f.name);
          ngModel.$ngfValidations.push({name: 'resize', valid: false});
          upload.applyModelValidation(ngModel, files);
        });
      }
    }

    for (var i = 0; i < files.length; i++) {
      handleFile(files[i], i);
    }
    return $q.all(promises);
  }

  upload.updateModel = function (ngModel, attr, scope, fileChange, files, evt, noDelay) {
    function update(files, invalidFiles, newFiles, dupFiles, isSingleModel) {
      attr.$$ngfPrevValidFiles = files;
      attr.$$ngfPrevInvalidFiles = invalidFiles;
      var file = files && files.length ? files[0] : null;
      var invalidFile = invalidFiles && invalidFiles.length ? invalidFiles[0] : null;

      if (ngModel) {
        upload.applyModelValidation(ngModel, files);
        ngModel.$setViewValue(isSingleModel ? file : files);
      }

      if (fileChange) {
        $parse(fileChange)(scope, {
          $files: files,
          $file: file,
          $newFiles: newFiles,
          $duplicateFiles: dupFiles,
          $invalidFiles: invalidFiles,
          $invalidFile: invalidFile,
          $event: evt
        });
      }

      var invalidModel = upload.attrGetter('ngfModelInvalid', attr);
      if (invalidModel) {
        $timeout(function () {
          $parse(invalidModel).assign(scope, isSingleModel ? invalidFile : invalidFiles);
        });
      }
      $timeout(function () {
        // scope apply changes
      });
    }

    var allNewFiles, dupFiles = [], prevValidFiles, prevInvalidFiles,
      invalids = [], valids = [];

    function removeDuplicates() {
      function equals(f1, f2) {
        return f1.name === f2.name && (f1.$ngfOrigSize || f1.size) === (f2.$ngfOrigSize || f2.size) &&
          f1.type === f2.type;
      }

      function isInPrevFiles(f) {
        var j;
        for (j = 0; j < prevValidFiles.length; j++) {
          if (equals(f, prevValidFiles[j])) {
            return true;
          }
        }
        for (j = 0; j < prevInvalidFiles.length; j++) {
          if (equals(f, prevInvalidFiles[j])) {
            return true;
          }
        }
        return false;
      }

      if (files) {
        allNewFiles = [];
        dupFiles = [];
        for (var i = 0; i < files.length; i++) {
          if (isInPrevFiles(files[i])) {
            dupFiles.push(files[i]);
          } else {
            allNewFiles.push(files[i]);
          }
        }
      }
    }

    function toArray(v) {
      return angular.isArray(v) ? v : [v];
    }

    function resizeAndUpdate() {
      function updateModel() {
        $timeout(function () {
          update(keep ? prevValidFiles.concat(valids) : valids,
            keep ? prevInvalidFiles.concat(invalids) : invalids,
            files, dupFiles, isSingleModel);
        }, options && options.debounce ? options.debounce.change || options.debounce : 0);
      }

      var resizingFiles = validateAfterResize ? allNewFiles : valids;
      resizeFile(resizingFiles, attr, scope, ngModel).then(function () {
        if (validateAfterResize) {
          upload.validate(allNewFiles, keep ? prevValidFiles.length : 0, ngModel, attr, scope)
            .then(function (validationResult) {
              valids = validationResult.validsFiles;
              invalids = validationResult.invalidsFiles;
              updateModel();
            });
        } else {
          updateModel();
        }
      }, function () {
        for (var i = 0; i < resizingFiles.length; i++) {
          var f = resizingFiles[i];
          if (f.$error === 'resize') {
            var index = valids.indexOf(f);
            if (index > -1) {
              valids.splice(index, 1);
              invalids.push(f);
            }
            updateModel();
          }
        }
      });
    }

    prevValidFiles = attr.$$ngfPrevValidFiles || [];
    prevInvalidFiles = attr.$$ngfPrevInvalidFiles || [];
    if (ngModel && ngModel.$modelValue) {
      prevValidFiles = toArray(ngModel.$modelValue);
    }

    var keep = upload.attrGetter('ngfKeep', attr, scope);
    allNewFiles = (files || []).slice(0);
    if (keep === 'distinct' || upload.attrGetter('ngfKeepDistinct', attr, scope) === true) {
      removeDuplicates(attr, scope);
    }

    var isSingleModel = !keep && !upload.attrGetter('ngfMultiple', attr, scope) && !upload.attrGetter('multiple', attr);

    if (keep && !allNewFiles.length) return;

    upload.attrGetter('ngfBeforeModelChange', attr, scope, {
      $files: files,
      $file: files && files.length ? files[0] : null,
      $newFiles: allNewFiles,
      $duplicateFiles: dupFiles,
      $event: evt
    });

    var validateAfterResize = upload.attrGetter('ngfValidateAfterResize', attr, scope);

    var options = upload.attrGetter('ngfModelOptions', attr, scope);
    upload.validate(allNewFiles, keep ? prevValidFiles.length : 0, ngModel, attr, scope)
      .then(function (validationResult) {
      if (noDelay) {
        update(allNewFiles, [], files, dupFiles, isSingleModel);
      } else {
        if ((!options || !options.allowInvalid) && !validateAfterResize) {
          valids = validationResult.validFiles;
          invalids = validationResult.invalidFiles;
        } else {
          valids = allNewFiles;
        }
        if (upload.attrGetter('ngfFixOrientation', attr, scope) && upload.isExifSupported()) {
          applyExifRotations(valids, attr, scope).then(function () {
            resizeAndUpdate();
          });
        } else {
          resizeAndUpdate();
        }
      }
    });
  };

  return upload;
}]);

ngFileUpload.directive('ngfSelect', ['$parse', '$timeout', '$compile', 'Upload', function ($parse, $timeout, $compile, Upload) {
  var generatedElems = [];

  function isDelayedClickSupported(ua) {
    // fix for android native browser < 4.4 and safari windows
    var m = ua.match(/Android[^\d]*(\d+)\.(\d+)/);
    if (m && m.length > 2) {
      var v = Upload.defaults.androidFixMinorVersion || 4;
      return parseInt(m[1]) < 4 || (parseInt(m[1]) === v && parseInt(m[2]) < v);
    }

    // safari on windows
    return ua.indexOf('Chrome') === -1 && /.*Windows.*Safari.*/.test(ua);
  }

  function linkFileSelect(scope, elem, attr, ngModel, $parse, $timeout, $compile, upload) {
    /** @namespace attr.ngfSelect */
    /** @namespace attr.ngfChange */
    /** @namespace attr.ngModel */
    /** @namespace attr.ngfModelOptions */
    /** @namespace attr.ngfMultiple */
    /** @namespace attr.ngfCapture */
    /** @namespace attr.ngfValidate */
    /** @namespace attr.ngfKeep */
    var attrGetter = function (name, scope) {
      return upload.attrGetter(name, attr, scope);
    };

    function isInputTypeFile() {
      return elem[0].tagName.toLowerCase() === 'input' && attr.type && attr.type.toLowerCase() === 'file';
    }

    function fileChangeAttr() {
      return attrGetter('ngfChange') || attrGetter('ngfSelect');
    }

    function changeFn(evt) {
      if (upload.shouldUpdateOn('change', attr, scope)) {
        var fileList = evt.__files_ || (evt.target && evt.target.files), files = [];
        /* Handle duplicate call in  IE11 */
        if (!fileList) return;
        for (var i = 0; i < fileList.length; i++) {
          files.push(fileList[i]);
        }
        upload.updateModel(ngModel, attr, scope, fileChangeAttr(),
          files.length ? files : null, evt);
      }
    }

    upload.registerModelChangeValidator(ngModel, attr, scope);

    var unwatches = [];
    if (attrGetter('ngfMultiple')) {
      unwatches.push(scope.$watch(attrGetter('ngfMultiple'), function () {
        fileElem.attr('multiple', attrGetter('ngfMultiple', scope));
      }));
    }
    if (attrGetter('ngfCapture')) {
      unwatches.push(scope.$watch(attrGetter('ngfCapture'), function () {
        fileElem.attr('capture', attrGetter('ngfCapture', scope));
      }));
    }
    if (attrGetter('ngfAccept')) {
      unwatches.push(scope.$watch(attrGetter('ngfAccept'), function () {
        fileElem.attr('accept', attrGetter('ngfAccept', scope));
      }));
    }
    unwatches.push(attr.$observe('accept', function () {
      fileElem.attr('accept', attrGetter('accept'));
    }));
    function bindAttrToFileInput(fileElem, label) {
      function updateId(val) {
        fileElem.attr('id', 'ngf-' + val);
        label.attr('id', 'ngf-label-' + val);
      }

      for (var i = 0; i < elem[0].attributes.length; i++) {
        var attribute = elem[0].attributes[i];
        if (attribute.name !== 'type' && attribute.name !== 'class' && attribute.name !== 'style') {
          if (attribute.name === 'id') {
            updateId(attribute.value);
            unwatches.push(attr.$observe('id', updateId));
          } else {
            fileElem.attr(attribute.name, (!attribute.value && (attribute.name === 'required' ||
            attribute.name === 'multiple')) ? attribute.name : attribute.value);
          }
        }
      }
    }

    function createFileInput() {
      if (isInputTypeFile()) {
        return elem;
      }

      var fileElem = angular.element('<input type="file">');

      var label = angular.element('<label>upload</label>');
      label.css('visibility', 'hidden').css('position', 'absolute').css('overflow', 'hidden')
        .css('width', '0px').css('height', '0px').css('border', 'none')
        .css('margin', '0px').css('padding', '0px').attr('tabindex', '-1');
      bindAttrToFileInput(fileElem, label);

      generatedElems.push({el: elem, ref: label});

      document.body.appendChild(label.append(fileElem)[0]);

      return fileElem;
    }

    function clickHandler(evt) {
      if (elem.attr('disabled')) return false;
      if (attrGetter('ngfSelectDisabled', scope)) return;

      var r = detectSwipe(evt);
      // prevent the click if it is a swipe
      if (r != null) return r;

      resetModel(evt);

      // fix for md when the element is removed from the DOM and added back #460
      try {
        if (!isInputTypeFile() && !document.body.contains(fileElem[0])) {
          generatedElems.push({el: elem, ref: fileElem.parent()});
          document.body.appendChild(fileElem.parent()[0]);
          fileElem.bind('change', changeFn);
        }
      } catch (e) {/*ignore*/
      }

      if (isDelayedClickSupported(navigator.userAgent)) {
        setTimeout(function () {
          fileElem[0].click();
        }, 0);
      } else {
        fileElem[0].click();
      }

      return false;
    }


    var initialTouchStartY = 0;
    var initialTouchStartX = 0;

    function detectSwipe(evt) {
      var touches = evt.changedTouches || (evt.originalEvent && evt.originalEvent.changedTouches);
      if (touches) {
        if (evt.type === 'touchstart') {
          initialTouchStartX = touches[0].clientX;
          initialTouchStartY = touches[0].clientY;
          return true; // don't block event default
        } else {
          // prevent scroll from triggering event
          if (evt.type === 'touchend') {
            var currentX = touches[0].clientX;
            var currentY = touches[0].clientY;
            if ((Math.abs(currentX - initialTouchStartX) > 20) ||
              (Math.abs(currentY - initialTouchStartY) > 20)) {
              evt.stopPropagation();
              evt.preventDefault();
              return false;
            }
          }
          return true;
        }
      }
    }

    var fileElem = elem;

    function resetModel(evt) {
      if (upload.shouldUpdateOn('click', attr, scope) && fileElem.val()) {
        fileElem.val(null);
        upload.updateModel(ngModel, attr, scope, fileChangeAttr(), null, evt, true);
      }
    }

    if (!isInputTypeFile()) {
      fileElem = createFileInput();
    }
    fileElem.bind('change', changeFn);

    if (!isInputTypeFile()) {
      elem.bind('click touchstart touchend', clickHandler);
    } else {
      elem.bind('click', resetModel);
    }

    function ie10SameFileSelectFix(evt) {
      if (fileElem && !fileElem.attr('__ngf_ie10_Fix_')) {
        if (!fileElem[0].parentNode) {
          fileElem = null;
          return;
        }
        evt.preventDefault();
        evt.stopPropagation();
        fileElem.unbind('click');
        var clone = fileElem.clone();
        fileElem.replaceWith(clone);
        fileElem = clone;
        fileElem.attr('__ngf_ie10_Fix_', 'true');
        fileElem.bind('change', changeFn);
        fileElem.bind('click', ie10SameFileSelectFix);
        fileElem[0].click();
        return false;
      } else {
        fileElem.removeAttr('__ngf_ie10_Fix_');
      }
    }

    if (navigator.appVersion.indexOf('MSIE 10') !== -1) {
      fileElem.bind('click', ie10SameFileSelectFix);
    }

    if (ngModel) ngModel.$formatters.push(function (val) {
      if (val == null || val.length === 0) {
        if (fileElem.val()) {
          fileElem.val(null);
        }
      }
      return val;
    });

    scope.$on('$destroy', function () {
      if (!isInputTypeFile()) fileElem.parent().remove();
      angular.forEach(unwatches, function (unwatch) {
        unwatch();
      });
    });

    $timeout(function () {
      for (var i = 0; i < generatedElems.length; i++) {
        var g = generatedElems[i];
        if (!document.body.contains(g.el[0])) {
          generatedElems.splice(i, 1);
          g.ref.remove();
        }
      }
    });

    if (window.FileAPI && window.FileAPI.ngfFixIE) {
      window.FileAPI.ngfFixIE(elem, fileElem, changeFn);
    }
  }

  return {
    restrict: 'AEC',
    require: '?ngModel',
    link: function (scope, elem, attr, ngModel) {
      linkFileSelect(scope, elem, attr, ngModel, $parse, $timeout, $compile, Upload);
    }
  };
}]);

(function () {

  ngFileUpload.service('UploadDataUrl', ['UploadBase', '$timeout', '$q', function (UploadBase, $timeout, $q) {
    var upload = UploadBase;
    upload.base64DataUrl = function (file) {
      if (angular.isArray(file)) {
        var d = $q.defer(), count = 0;
        angular.forEach(file, function (f) {
          upload.dataUrl(f, true)['finally'](function () {
            count++;
            if (count === file.length) {
              var urls = [];
              angular.forEach(file, function (ff) {
                urls.push(ff.$ngfDataUrl);
              });
              d.resolve(urls, file);
            }
          });
        });
        return d.promise;
      } else {
        return upload.dataUrl(file, true);
      }
    };
    upload.dataUrl = function (file, disallowObjectUrl) {
      if (!file) return upload.emptyPromise(file, file);
      if ((disallowObjectUrl && file.$ngfDataUrl != null) || (!disallowObjectUrl && file.$ngfBlobUrl != null)) {
        return upload.emptyPromise(disallowObjectUrl ? file.$ngfDataUrl : file.$ngfBlobUrl, file);
      }
      var p = disallowObjectUrl ? file.$$ngfDataUrlPromise : file.$$ngfBlobUrlPromise;
      if (p) return p;

      var deferred = $q.defer();
      $timeout(function () {
        if (window.FileReader && file &&
          (!window.FileAPI || navigator.userAgent.indexOf('MSIE 8') === -1 || file.size < 20000) &&
          (!window.FileAPI || navigator.userAgent.indexOf('MSIE 9') === -1 || file.size < 4000000)) {
          //prefer URL.createObjectURL for handling refrences to files of all sizes
          //since it doesnÂ´t build a large string in memory
          var URL = window.URL || window.webkitURL;
          if (URL && URL.createObjectURL && !disallowObjectUrl) {
            var url;
            try {
              url = URL.createObjectURL(file);
            } catch (e) {
              $timeout(function () {
                file.$ngfBlobUrl = '';
                deferred.reject();
              });
              return;
            }
            $timeout(function () {
              file.$ngfBlobUrl = url;
              if (url) {
                deferred.resolve(url, file);
                upload.blobUrls = upload.blobUrls || [];
                upload.blobUrlsTotalSize = upload.blobUrlsTotalSize || 0;
                upload.blobUrls.push({url: url, size: file.size});
                upload.blobUrlsTotalSize += file.size || 0;
                var maxMemory = upload.defaults.blobUrlsMaxMemory || 268435456;
                var maxLength = upload.defaults.blobUrlsMaxQueueSize || 200;
                while ((upload.blobUrlsTotalSize > maxMemory || upload.blobUrls.length > maxLength) && upload.blobUrls.length > 1) {
                  var obj = upload.blobUrls.splice(0, 1)[0];
                  URL.revokeObjectURL(obj.url);
                  upload.blobUrlsTotalSize -= obj.size;
                }
              }
            });
          } else {
            var fileReader = new FileReader();
            fileReader.onload = function (e) {
              $timeout(function () {
                file.$ngfDataUrl = e.target.result;
                deferred.resolve(e.target.result, file);
                $timeout(function () {
                  delete file.$ngfDataUrl;
                }, 1000);
              });
            };
            fileReader.onerror = function () {
              $timeout(function () {
                file.$ngfDataUrl = '';
                deferred.reject();
              });
            };
            fileReader.readAsDataURL(file);
          }
        } else {
          $timeout(function () {
            file[disallowObjectUrl ? '$ngfDataUrl' : '$ngfBlobUrl'] = '';
            deferred.reject();
          });
        }
      });

      if (disallowObjectUrl) {
        p = file.$$ngfDataUrlPromise = deferred.promise;
      } else {
        p = file.$$ngfBlobUrlPromise = deferred.promise;
      }
      p['finally'](function () {
        delete file[disallowObjectUrl ? '$$ngfDataUrlPromise' : '$$ngfBlobUrlPromise'];
      });
      return p;
    };
    return upload;
  }]);

  function getTagType(el) {
    if (el.tagName.toLowerCase() === 'img') return 'image';
    if (el.tagName.toLowerCase() === 'audio') return 'audio';
    if (el.tagName.toLowerCase() === 'video') return 'video';
    return /./;
  }

  function linkFileDirective(Upload, $timeout, scope, elem, attr, directiveName, resizeParams, isBackground) {
    function constructDataUrl(file) {
      var disallowObjectUrl = Upload.attrGetter('ngfNoObjectUrl', attr, scope);
      Upload.dataUrl(file, disallowObjectUrl)['finally'](function () {
        $timeout(function () {
          var src = (disallowObjectUrl ? file.$ngfDataUrl : file.$ngfBlobUrl) || file.$ngfDataUrl;
          if (isBackground) {
            elem.css('background-image', 'url(\'' + (src || '') + '\')');
          } else {
            elem.attr('src', src);
          }
          if (src) {
            elem.removeClass('ng-hide');
          } else {
            elem.addClass('ng-hide');
          }
        });
      });
    }

    $timeout(function () {
      var unwatch = scope.$watch(attr[directiveName], function (file) {
        var size = resizeParams;
        if (directiveName === 'ngfThumbnail') {
          if (!size) {
            size = {
              width: elem[0].naturalWidth || elem[0].clientWidth,
              height: elem[0].naturalHeight || elem[0].clientHeight
            };
          }
          if (size.width === 0 && window.getComputedStyle) {
            var style = getComputedStyle(elem[0]);
            if (style.width && style.width.indexOf('px') > -1 && style.height && style.height.indexOf('px') > -1) {
              size = {
                width: parseInt(style.width.slice(0, -2)),
                height: parseInt(style.height.slice(0, -2))
              };
            }
          }
        }

        if (angular.isString(file)) {
          elem.removeClass('ng-hide');
          if (isBackground) {
            return elem.css('background-image', 'url(\'' + file + '\')');
          } else {
            return elem.attr('src', file);
          }
        }
        if (file && file.type && file.type.search(getTagType(elem[0])) === 0 &&
          (!isBackground || file.type.indexOf('image') === 0)) {
          if (size && Upload.isResizeSupported()) {
            size.resizeIf = function (width, height) {
              return Upload.attrGetter('ngfResizeIf', attr, scope,
                {$width: width, $height: height, $file: file});
            };
            Upload.resize(file, size).then(
              function (f) {
                constructDataUrl(f);
              }, function (e) {
                throw e;
              }
            );
          } else {
            constructDataUrl(file);
          }
        } else {
          elem.addClass('ng-hide');
        }
      });

      scope.$on('$destroy', function () {
        unwatch();
      });
    });
  }


  /** @namespace attr.ngfSrc */
  /** @namespace attr.ngfNoObjectUrl */
  ngFileUpload.directive('ngfSrc', ['Upload', '$timeout', function (Upload, $timeout) {
    return {
      restrict: 'AE',
      link: function (scope, elem, attr) {
        linkFileDirective(Upload, $timeout, scope, elem, attr, 'ngfSrc',
          Upload.attrGetter('ngfResize', attr, scope), false);
      }
    };
  }]);

  /** @namespace attr.ngfBackground */
  /** @namespace attr.ngfNoObjectUrl */
  ngFileUpload.directive('ngfBackground', ['Upload', '$timeout', function (Upload, $timeout) {
    return {
      restrict: 'AE',
      link: function (scope, elem, attr) {
        linkFileDirective(Upload, $timeout, scope, elem, attr, 'ngfBackground',
          Upload.attrGetter('ngfResize', attr, scope), true);
      }
    };
  }]);

  /** @namespace attr.ngfThumbnail */
  /** @namespace attr.ngfAsBackground */
  /** @namespace attr.ngfSize */
  /** @namespace attr.ngfNoObjectUrl */
  ngFileUpload.directive('ngfThumbnail', ['Upload', '$timeout', function (Upload, $timeout) {
    return {
      restrict: 'AE',
      link: function (scope, elem, attr) {
        var size = Upload.attrGetter('ngfSize', attr, scope);
        linkFileDirective(Upload, $timeout, scope, elem, attr, 'ngfThumbnail', size,
          Upload.attrGetter('ngfAsBackground', attr, scope));
      }
    };
  }]);

  ngFileUpload.config(['$compileProvider', function ($compileProvider) {
    if ($compileProvider.imgSrcSanitizationWhitelist) $compileProvider.imgSrcSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|webcal|local|file|data|blob):/);
    if ($compileProvider.aHrefSanitizationWhitelist) $compileProvider.aHrefSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|webcal|local|file|data|blob):/);
  }]);

  ngFileUpload.filter('ngfDataUrl', ['UploadDataUrl', '$sce', function (UploadDataUrl, $sce) {
    return function (file, disallowObjectUrl, trustedUrl) {
      if (angular.isString(file)) {
        return $sce.trustAsResourceUrl(file);
      }
      var src = file && ((disallowObjectUrl ? file.$ngfDataUrl : file.$ngfBlobUrl) || file.$ngfDataUrl);
      if (file && !src) {
        if (!file.$ngfDataUrlFilterInProgress && angular.isObject(file)) {
          file.$ngfDataUrlFilterInProgress = true;
          UploadDataUrl.dataUrl(file, disallowObjectUrl);
        }
        return '';
      }
      if (file) delete file.$ngfDataUrlFilterInProgress;
      return (file && src ? (trustedUrl ? $sce.trustAsResourceUrl(src) : src) : file) || '';
    };
  }]);

})();

ngFileUpload.service('UploadValidate', ['UploadDataUrl', '$q', '$timeout', function (UploadDataUrl, $q, $timeout) {
  var upload = UploadDataUrl;

  function globStringToRegex(str) {
    var regexp = '', excludes = [];
    if (str.length > 2 && str[0] === '/' && str[str.length - 1] === '/') {
      regexp = str.substring(1, str.length - 1);
    } else {
      var split = str.split(',');
      if (split.length > 1) {
        for (var i = 0; i < split.length; i++) {
          var r = globStringToRegex(split[i]);
          if (r.regexp) {
            regexp += '(' + r.regexp + ')';
            if (i < split.length - 1) {
              regexp += '|';
            }
          } else {
            excludes = excludes.concat(r.excludes);
          }
        }
      } else {
        if (str.indexOf('!') === 0) {
          excludes.push('^((?!' + globStringToRegex(str.substring(1)).regexp + ').)*$');
        } else {
          if (str.indexOf('.') === 0) {
            str = '*' + str;
          }
          regexp = '^' + str.replace(new RegExp('[.\\\\+*?\\[\\^\\]$(){}=!<>|:\\-]', 'g'), '\\$&') + '$';
          regexp = regexp.replace(/\\\*/g, '.*').replace(/\\\?/g, '.');
        }
      }
    }
    return {regexp: regexp, excludes: excludes};
  }

  upload.validatePattern = function (file, val) {
    if (!val) {
      return true;
    }
    var pattern = globStringToRegex(val), valid = true;
    if (pattern.regexp && pattern.regexp.length) {
      var regexp = new RegExp(pattern.regexp, 'i');
      valid = (file.type != null && regexp.test(file.type)) ||
        (file.name != null && regexp.test(file.name));
    }
    var len = pattern.excludes.length;
    while (len--) {
      var exclude = new RegExp(pattern.excludes[len], 'i');
      valid = valid && (file.type == null || exclude.test(file.type)) &&
        (file.name == null || exclude.test(file.name));
    }
    return valid;
  };

  upload.ratioToFloat = function (val) {
    var r = val.toString(), xIndex = r.search(/[x:]/i);
    if (xIndex > -1) {
      r = parseFloat(r.substring(0, xIndex)) / parseFloat(r.substring(xIndex + 1));
    } else {
      r = parseFloat(r);
    }
    return r;
  };

  upload.registerModelChangeValidator = function (ngModel, attr, scope) {
    if (ngModel) {
      ngModel.$formatters.push(function (files) {
        if (ngModel.$dirty) {
          var filesArray = files;
          if (files && !angular.isArray(files)) {
            filesArray = [files];
          }
          upload.validate(filesArray, 0, ngModel, attr, scope).then(function () {
            upload.applyModelValidation(ngModel, filesArray);
          });
        }
        return files;
      });
    }
  };

  function markModelAsDirty(ngModel, files) {
    if (files != null && !ngModel.$dirty) {
      if (ngModel.$setDirty) {
        ngModel.$setDirty();
      } else {
        ngModel.$dirty = true;
      }
    }
  }

  upload.applyModelValidation = function (ngModel, files) {
    markModelAsDirty(ngModel, files);
    angular.forEach(ngModel.$ngfValidations, function (validation) {
      ngModel.$setValidity(validation.name, validation.valid);
    });
  };

  upload.getValidationAttr = function (attr, scope, name, validationName, file) {
    var dName = 'ngf' + name[0].toUpperCase() + name.substr(1);
    var val = upload.attrGetter(dName, attr, scope, {$file: file});
    if (val == null) {
      val = upload.attrGetter('ngfValidate', attr, scope, {$file: file});
      if (val) {
        var split = (validationName || name).split('.');
        val = val[split[0]];
        if (split.length > 1) {
          val = val && val[split[1]];
        }
      }
    }
    return val;
  };

  upload.validate = function (files, prevLength, ngModel, attr, scope) {
    ngModel = ngModel || {};
    ngModel.$ngfValidations = ngModel.$ngfValidations || [];

    angular.forEach(ngModel.$ngfValidations, function (v) {
      v.valid = true;
    });

    var attrGetter = function (name, params) {
      return upload.attrGetter(name, attr, scope, params);
    };

    var ignoredErrors = (upload.attrGetter('ngfIgnoreInvalid', attr, scope) || '').split(' ');
    var runAllValidation = upload.attrGetter('ngfRunAllValidations', attr, scope);

    if (files == null || files.length === 0) {
      return upload.emptyPromise({'validFiles': files, 'invalidFiles': []});
    }

    files = files.length === undefined ? [files] : files.slice(0);
    var invalidFiles = [];

    function validateSync(name, validationName, fn) {
      if (files) {
        var i = files.length, valid = null;
        while (i--) {
          var file = files[i];
          if (file) {
            var val = upload.getValidationAttr(attr, scope, name, validationName, file);
            if (val != null) {
              if (!fn(file, val, i)) {
                if (ignoredErrors.indexOf(name) === -1) {
                  file.$error = name;
                  (file.$errorMessages = (file.$errorMessages || {}))[name] = true;
                  file.$errorParam = val;
                  if (invalidFiles.indexOf(file) === -1) {
                    invalidFiles.push(file);
                  }
                  if (!runAllValidation) {
                    files.splice(i, 1);
                  }
                  valid = false;
                } else {
                  files.splice(i, 1);
                }
              }
            }
          }
        }
        if (valid !== null) {
          ngModel.$ngfValidations.push({name: name, valid: valid});
        }
      }
    }

    validateSync('pattern', null, upload.validatePattern);
    validateSync('minSize', 'size.min', function (file, val) {
      return file.size + 0.1 >= upload.translateScalars(val);
    });
    validateSync('maxSize', 'size.max', function (file, val) {
      return file.size - 0.1 <= upload.translateScalars(val);
    });
    var totalSize = 0;
    validateSync('maxTotalSize', null, function (file, val) {
      totalSize += file.size;
      if (totalSize > upload.translateScalars(val)) {
        files.splice(0, files.length);
        return false;
      }
      return true;
    });

    validateSync('validateFn', null, function (file, r) {
      return r === true || r === null || r === '';
    });

    if (!files.length) {
      return upload.emptyPromise({'validFiles': [], 'invalidFiles': invalidFiles});
    }

    function validateAsync(name, validationName, type, asyncFn, fn) {
      function resolveResult(defer, file, val) {
        function resolveInternal(fn) {
          if (fn()) {
            if (ignoredErrors.indexOf(name) === -1) {
              file.$error = name;
              (file.$errorMessages = (file.$errorMessages || {}))[name] = true;
              file.$errorParam = val;
              if (invalidFiles.indexOf(file) === -1) {
                invalidFiles.push(file);
              }
              if (!runAllValidation) {
                var i = files.indexOf(file);
                if (i > -1) files.splice(i, 1);
              }
              defer.resolve(false);
            } else {
              var j = files.indexOf(file);
              if (j > -1) files.splice(j, 1);
              defer.resolve(true);
            }
          } else {
            defer.resolve(true);
          }
        }

        if (val != null) {
          asyncFn(file, val).then(function (d) {
            resolveInternal(function () {
              return !fn(d, val);
            });
          }, function () {
            resolveInternal(function () {
              return attrGetter('ngfValidateForce', {$file: file});
            });
          });
        } else {
          defer.resolve(true);
        }
      }

      var promises = [upload.emptyPromise(true)];
      if (files) {
        files = files.length === undefined ? [files] : files;
        angular.forEach(files, function (file) {
          var defer = $q.defer();
          promises.push(defer.promise);
          if (type && (file.type == null || file.type.search(type) !== 0)) {
            defer.resolve(true);
            return;
          }
          if (name === 'dimensions' && upload.attrGetter('ngfDimensions', attr) != null) {
            upload.imageDimensions(file).then(function (d) {
              resolveResult(defer, file,
                attrGetter('ngfDimensions', {$file: file, $width: d.width, $height: d.height}));
            }, function () {
              defer.resolve(false);
            });
          } else if (name === 'duration' && upload.attrGetter('ngfDuration', attr) != null) {
            upload.mediaDuration(file).then(function (d) {
              resolveResult(defer, file,
                attrGetter('ngfDuration', {$file: file, $duration: d}));
            }, function () {
              defer.resolve(false);
            });
          } else {
            resolveResult(defer, file,
              upload.getValidationAttr(attr, scope, name, validationName, file));
          }
        });
      }
      var deffer = $q.defer();
      $q.all(promises).then(function (values) {
        var isValid = true;
        for (var i = 0; i < values.length; i++) {
          if (!values[i]) {
            isValid = false;
            break;
          }
        }
        ngModel.$ngfValidations.push({name: name, valid: isValid});
        deffer.resolve(isValid);
      });
      return deffer.promise;
    }

    var deffer = $q.defer();
    var promises = [];

    promises.push(validateAsync('maxHeight', 'height.max', /image/,
      this.imageDimensions, function (d, val) {
        return d.height <= val;
      }));
    promises.push(validateAsync('minHeight', 'height.min', /image/,
      this.imageDimensions, function (d, val) {
        return d.height >= val;
      }));
    promises.push(validateAsync('maxWidth', 'width.max', /image/,
      this.imageDimensions, function (d, val) {
        return d.width <= val;
      }));
    promises.push(validateAsync('minWidth', 'width.min', /image/,
      this.imageDimensions, function (d, val) {
        return d.width >= val;
      }));
    promises.push(validateAsync('dimensions', null, /image/,
      function (file, val) {
        return upload.emptyPromise(val);
      }, function (r) {
        return r;
      }));
    promises.push(validateAsync('ratio', null, /image/,
      this.imageDimensions, function (d, val) {
        var split = val.toString().split(','), valid = false;
        for (var i = 0; i < split.length; i++) {
          if (Math.abs((d.width / d.height) - upload.ratioToFloat(split[i])) < 0.01) {
            valid = true;
          }
        }
        return valid;
      }));
    promises.push(validateAsync('maxRatio', 'ratio.max', /image/,
      this.imageDimensions, function (d, val) {
        return (d.width / d.height) - upload.ratioToFloat(val) < 0.0001;
      }));
    promises.push(validateAsync('minRatio', 'ratio.min', /image/,
      this.imageDimensions, function (d, val) {
        return (d.width / d.height) - upload.ratioToFloat(val) > -0.0001;
      }));
    promises.push(validateAsync('maxDuration', 'duration.max', /audio|video/,
      this.mediaDuration, function (d, val) {
        return d <= upload.translateScalars(val);
      }));
    promises.push(validateAsync('minDuration', 'duration.min', /audio|video/,
      this.mediaDuration, function (d, val) {
        return d >= upload.translateScalars(val);
      }));
    promises.push(validateAsync('duration', null, /audio|video/,
      function (file, val) {
        return upload.emptyPromise(val);
      }, function (r) {
        return r;
      }));

    promises.push(validateAsync('validateAsyncFn', null, null,
      function (file, val) {
        return val;
      }, function (r) {
        return r === true || r === null || r === '';
      }));

    $q.all(promises).then(function () {

      if (runAllValidation) {
        for (var i = 0; i < files.length; i++) {
          var file = files[i];
          if (file.$error) {
            files.splice(i--, 1);
          }
        }
      }

      runAllValidation = false;
      validateSync('maxFiles', null, function (file, val, i) {
        return prevLength + i < val;
      });

      deffer.resolve({'validFiles': files, 'invalidFiles': invalidFiles});
    });
    return deffer.promise;
  };

  upload.imageDimensions = function (file) {
    if (file.$ngfWidth && file.$ngfHeight) {
      var d = $q.defer();
      $timeout(function () {
        d.resolve({width: file.$ngfWidth, height: file.$ngfHeight});
      });
      return d.promise;
    }
    if (file.$ngfDimensionPromise) return file.$ngfDimensionPromise;

    var deferred = $q.defer();
    $timeout(function () {
      if (file.type.indexOf('image') !== 0) {
        deferred.reject('not image');
        return;
      }
      upload.dataUrl(file).then(function (dataUrl) {
        var img = angular.element('<img>').attr('src', dataUrl)
          .css('visibility', 'hidden').css('position', 'fixed')
          .css('max-width', 'none !important').css('max-height', 'none !important');

        function success() {
          var width = img[0].naturalWidth || img[0].clientWidth;
          var height = img[0].naturalHeight || img[0].clientHeight;
          img.remove();
          file.$ngfWidth = width;
          file.$ngfHeight = height;
          deferred.resolve({width: width, height: height});
        }

        function error() {
          img.remove();
          deferred.reject('load error');
        }

        img.on('load', success);
        img.on('error', error);

        var secondsCounter = 0;
        function checkLoadErrorInCaseOfNoCallback() {
          $timeout(function () {
            if (img[0].parentNode) {
              if (img[0].clientWidth) {
                success();
              } else if (secondsCounter++ > 10) {
                error();
              } else {
                checkLoadErrorInCaseOfNoCallback();
              }
            }
          }, 1000);
        }

        checkLoadErrorInCaseOfNoCallback();

        angular.element(document.getElementsByTagName('body')[0]).append(img);
      }, function () {
        deferred.reject('load error');
      });
    });

    file.$ngfDimensionPromise = deferred.promise;
    file.$ngfDimensionPromise['finally'](function () {
      delete file.$ngfDimensionPromise;
    });
    return file.$ngfDimensionPromise;
  };

  upload.mediaDuration = function (file) {
    if (file.$ngfDuration) {
      var d = $q.defer();
      $timeout(function () {
        d.resolve(file.$ngfDuration);
      });
      return d.promise;
    }
    if (file.$ngfDurationPromise) return file.$ngfDurationPromise;

    var deferred = $q.defer();
    $timeout(function () {
      if (file.type.indexOf('audio') !== 0 && file.type.indexOf('video') !== 0) {
        deferred.reject('not media');
        return;
      }
      upload.dataUrl(file).then(function (dataUrl) {
        var el = angular.element(file.type.indexOf('audio') === 0 ? '<audio>' : '<video>')
          .attr('src', dataUrl).css('visibility', 'none').css('position', 'fixed');

        function success() {
          var duration = el[0].duration;
          file.$ngfDuration = duration;
          el.remove();
          deferred.resolve(duration);
        }

        function error() {
          el.remove();
          deferred.reject('load error');
        }

        el.on('loadedmetadata', success);
        el.on('error', error);
        var count = 0;

        function checkLoadError() {
          $timeout(function () {
            if (el[0].parentNode) {
              if (el[0].duration) {
                success();
              } else if (count > 10) {
                error();
              } else {
                checkLoadError();
              }
            }
          }, 1000);
        }

        checkLoadError();

        angular.element(document.body).append(el);
      }, function () {
        deferred.reject('load error');
      });
    });

    file.$ngfDurationPromise = deferred.promise;
    file.$ngfDurationPromise['finally'](function () {
      delete file.$ngfDurationPromise;
    });
    return file.$ngfDurationPromise;
  };
  return upload;
}
]);

ngFileUpload.service('UploadResize', ['UploadValidate', '$q', function (UploadValidate, $q) {
  var upload = UploadValidate;

  /**
   * Conserve aspect ratio of the original region. Useful when shrinking/enlarging
   * images to fit into a certain area.
   * Source:  http://stackoverflow.com/a/14731922
   *
   * @param {Number} srcWidth Source area width
   * @param {Number} srcHeight Source area height
   * @param {Number} maxWidth Nestable area maximum available width
   * @param {Number} maxHeight Nestable area maximum available height
   * @return {Object} { width, height }
   */
  var calculateAspectRatioFit = function (srcWidth, srcHeight, maxWidth, maxHeight, centerCrop) {
    var ratio = centerCrop ? Math.max(maxWidth / srcWidth, maxHeight / srcHeight) :
      Math.min(maxWidth / srcWidth, maxHeight / srcHeight);
    return {
      width: srcWidth * ratio, height: srcHeight * ratio,
      marginX: srcWidth * ratio - maxWidth, marginY: srcHeight * ratio - maxHeight
    };
  };

  // Extracted from https://github.com/romelgomez/angular-firebase-image-upload/blob/master/app/scripts/fileUpload.js#L89
  var resize = function (imagen, width, height, quality, type, ratio, centerCrop, resizeIf) {
    var deferred = $q.defer();
    var canvasElement = document.createElement('canvas');
    var imageElement = document.createElement('img');
    imageElement.setAttribute('style', 'visibility:hidden;position:fixed;z-index:-100000');
    document.body.appendChild(imageElement);

    imageElement.onload = function () {
      var imgWidth = imageElement.width, imgHeight = imageElement.height;
      imageElement.parentNode.removeChild(imageElement);
      if (resizeIf != null && resizeIf(imgWidth, imgHeight) === false) {
        deferred.reject('resizeIf');
        return;
      }
      try {
        if (ratio) {
          var ratioFloat = upload.ratioToFloat(ratio);
          var imgRatio = imgWidth / imgHeight;
          if (imgRatio < ratioFloat) {
            width = imgWidth;
            height = width / ratioFloat;
          } else {
            height = imgHeight;
            width = height * ratioFloat;
          }
        }
        if (!width) {
          width = imgWidth;
        }
        if (!height) {
          height = imgHeight;
        }
        var dimensions = calculateAspectRatioFit(imgWidth, imgHeight, width, height, centerCrop);
        canvasElement.width = Math.min(dimensions.width, width);
        canvasElement.height = Math.min(dimensions.height, height);
        var context = canvasElement.getContext('2d');
        context.drawImage(imageElement,
          Math.min(0, -dimensions.marginX / 2), Math.min(0, -dimensions.marginY / 2),
          dimensions.width, dimensions.height);
        deferred.resolve(canvasElement.toDataURL(type || 'image/WebP', quality || 0.934));
      } catch (e) {
        deferred.reject(e);
      }
    };
    imageElement.onerror = function () {
      imageElement.parentNode.removeChild(imageElement);
      deferred.reject();
    };
    imageElement.src = imagen;
    return deferred.promise;
  };

  upload.dataUrltoBlob = function (dataurl, name, origSize) {
    var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1],
      bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
    while (n--) {
      u8arr[n] = bstr.charCodeAt(n);
    }
    var blob = new window.Blob([u8arr], {type: mime});
    blob.name = name;
    blob.$ngfOrigSize = origSize;
    return blob;
  };

  upload.isResizeSupported = function () {
    var elem = document.createElement('canvas');
    return window.atob && elem.getContext && elem.getContext('2d') && window.Blob;
  };

  if (upload.isResizeSupported()) {
    // add name getter to the blob constructor prototype
    Object.defineProperty(window.Blob.prototype, 'name', {
      get: function () {
        return this.$ngfName;
      },
      set: function (v) {
        this.$ngfName = v;
      },
      configurable: true
    });
  }

  upload.resize = function (file, options) {
    if (file.type.indexOf('image') !== 0) return upload.emptyPromise(file);

    var deferred = $q.defer();
    upload.dataUrl(file, true).then(function (url) {
      resize(url, options.width, options.height, options.quality, options.type || file.type,
        options.ratio, options.centerCrop, options.resizeIf)
        .then(function (dataUrl) {
          if (file.type === 'image/jpeg' && options.restoreExif !== false) {
            try {
              dataUrl = upload.restoreExif(url, dataUrl);
            } catch (e) {
              setTimeout(function () {throw e;}, 1);
            }
          }
          try {
            var blob = upload.dataUrltoBlob(dataUrl, file.name, file.size);
            deferred.resolve(blob);
          } catch (e) {
            deferred.reject(e);
          }
        }, function (r) {
          if (r === 'resizeIf') {
            deferred.resolve(file);
          }
          deferred.reject(r);
        });
    }, function (e) {
      deferred.reject(e);
    });
    return deferred.promise;
  };

  return upload;
}]);

(function () {
  ngFileUpload.directive('ngfDrop', ['$parse', '$timeout', '$window', 'Upload', '$http', '$q',
    function ($parse, $timeout, $window, Upload, $http, $q) {
      return {
        restrict: 'AEC',
        require: '?ngModel',
        link: function (scope, elem, attr, ngModel) {
          linkDrop(scope, elem, attr, ngModel, $parse, $timeout, $window, Upload, $http, $q);
        }
      };
    }]);

  ngFileUpload.directive('ngfNoFileDrop', function () {
    return function (scope, elem) {
      if (dropAvailable()) elem.css('display', 'none');
    };
  });

  ngFileUpload.directive('ngfDropAvailable', ['$parse', '$timeout', 'Upload', function ($parse, $timeout, Upload) {
    return function (scope, elem, attr) {
      if (dropAvailable()) {
        var model = $parse(Upload.attrGetter('ngfDropAvailable', attr));
        $timeout(function () {
          model(scope);
          if (model.assign) {
            model.assign(scope, true);
          }
        });
      }
    };
  }]);

  function linkDrop(scope, elem, attr, ngModel, $parse, $timeout, $window, upload, $http, $q) {
    var available = dropAvailable();

    var attrGetter = function (name, scope, params) {
      return upload.attrGetter(name, attr, scope, params);
    };

    if (attrGetter('dropAvailable')) {
      $timeout(function () {
        if (scope[attrGetter('dropAvailable')]) {
          scope[attrGetter('dropAvailable')].value = available;
        } else {
          scope[attrGetter('dropAvailable')] = available;
        }
      });
    }
    if (!available) {
      if (attrGetter('ngfHideOnDropNotAvailable', scope) === true) {
        elem.css('display', 'none');
      }
      return;
    }

    function isDisabled() {
      return elem.attr('disabled') || attrGetter('ngfDropDisabled', scope);
    }

    if (attrGetter('ngfSelect') == null) {
      upload.registerModelChangeValidator(ngModel, attr, scope);
    }

    var leaveTimeout = null;
    var stopPropagation = $parse(attrGetter('ngfStopPropagation'));
    var dragOverDelay = 1;
    var actualDragOverClass;

    elem[0].addEventListener('dragover', function (evt) {
      if (isDisabled() || !upload.shouldUpdateOn('drop', attr, scope)) return;
      evt.preventDefault();
      if (stopPropagation(scope)) evt.stopPropagation();
      // handling dragover events from the Chrome download bar
      if (navigator.userAgent.indexOf('Chrome') > -1) {
        var b = evt.dataTransfer.effectAllowed;
        evt.dataTransfer.dropEffect = ('move' === b || 'linkMove' === b) ? 'move' : 'copy';
      }
      $timeout.cancel(leaveTimeout);
      if (!actualDragOverClass) {
        actualDragOverClass = 'C';
        calculateDragOverClass(scope, attr, evt, function (clazz) {
          actualDragOverClass = clazz;
          elem.addClass(actualDragOverClass);
          attrGetter('ngfDrag', scope, {$isDragging: true, $class: actualDragOverClass, $event: evt});
        });
      }
    }, false);
    elem[0].addEventListener('dragenter', function (evt) {
      if (isDisabled() || !upload.shouldUpdateOn('drop', attr, scope)) return;
      evt.preventDefault();
      if (stopPropagation(scope)) evt.stopPropagation();
    }, false);
    elem[0].addEventListener('dragleave', function (evt) {
      if (isDisabled() || !upload.shouldUpdateOn('drop', attr, scope)) return;
      evt.preventDefault();
      if (stopPropagation(scope)) evt.stopPropagation();
      leaveTimeout = $timeout(function () {
        if (actualDragOverClass) elem.removeClass(actualDragOverClass);
        actualDragOverClass = null;
        attrGetter('ngfDrag', scope, {$isDragging: false, $event: evt});
      }, dragOverDelay || 100);
    }, false);
    elem[0].addEventListener('drop', function (evt) {
      if (isDisabled() || !upload.shouldUpdateOn('drop', attr, scope)) return;
      evt.preventDefault();
      if (stopPropagation(scope)) evt.stopPropagation();
      if (actualDragOverClass) elem.removeClass(actualDragOverClass);
      actualDragOverClass = null;
      extractFilesAndUpdateModel(evt.dataTransfer, evt, 'dropUrl');
    }, false);
    elem[0].addEventListener('paste', function (evt) {
      if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1 &&
        attrGetter('ngfEnableFirefoxPaste', scope)) {
        evt.preventDefault();
      }
      if (isDisabled() || !upload.shouldUpdateOn('paste', attr, scope)) return;
      extractFilesAndUpdateModel(evt.clipboardData || evt.originalEvent.clipboardData, evt, 'pasteUrl');
    }, false);

    if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1 &&
      attrGetter('ngfEnableFirefoxPaste', scope)) {
      elem.attr('contenteditable', true);
      elem.on('keypress', function (e) {
        if (!e.metaKey && !e.ctrlKey) {
          e.preventDefault();
        }
      });
    }

    function extractFilesAndUpdateModel(source, evt, updateOnType) {
      if (!source) return;
      // html needs to be calculated on the same process otherwise the data will be wiped
      // after promise resolve or setTimeout.
      var html;
      try {
        html = source && source.getData && source.getData('text/html');
      } catch (e) {/* Fix IE11 that throw error calling getData */
      }
      extractFiles(source.items, source.files, attrGetter('ngfAllowDir', scope) !== false,
        attrGetter('multiple') || attrGetter('ngfMultiple', scope)).then(function (files) {
        if (files.length) {
          updateModel(files, evt);
        } else {
          extractFilesFromHtml(updateOnType, html).then(function (files) {
            updateModel(files, evt);
          });
        }
      });
    }

    function updateModel(files, evt) {
      upload.updateModel(ngModel, attr, scope, attrGetter('ngfChange') || attrGetter('ngfDrop'), files, evt);
    }

    function extractFilesFromHtml(updateOn, html) {
      if (!upload.shouldUpdateOn(updateOn, attr, scope) || typeof html !== 'string') return upload.rejectPromise([]);
      var urls = [];
      html.replace(/<(img src|img [^>]* src) *=\"([^\"]*)\"/gi, function (m, n, src) {
        urls.push(src);
      });
      var promises = [], files = [];
      if (urls.length) {
        angular.forEach(urls, function (url) {
          promises.push(upload.urlToBlob(url).then(function (blob) {
            files.push(blob);
          }));
        });
        var defer = $q.defer();
        $q.all(promises).then(function () {
          defer.resolve(files);
        }, function (e) {
          defer.reject(e);
        });
        return defer.promise;
      }
      return upload.emptyPromise();
    }

    function calculateDragOverClass(scope, attr, evt, callback) {
      var obj = attrGetter('ngfDragOverClass', scope, {$event: evt}), dClass = 'dragover';
      if (angular.isString(obj)) {
        dClass = obj;
      } else if (obj) {
        if (obj.delay) dragOverDelay = obj.delay;
        if (obj.accept || obj.reject) {
          var items = evt.dataTransfer.items;
          if (items == null || !items.length) {
            dClass = obj.accept;
          } else {
            var pattern = obj.pattern || attrGetter('ngfPattern', scope, {$event: evt});
            var len = items.length;
            while (len--) {
              if (!upload.validatePattern(items[len], pattern)) {
                dClass = obj.reject;
                break;
              } else {
                dClass = obj.accept;
              }
            }
          }
        }
      }
      callback(dClass);
    }

    function extractFiles(items, fileList, allowDir, multiple) {
      var maxFiles = upload.getValidationAttr(attr, scope, 'maxFiles');
      if (maxFiles == null) {
        maxFiles = Number.MAX_VALUE;
      }
      var maxTotalSize = upload.getValidationAttr(attr, scope, 'maxTotalSize');
      if (maxTotalSize == null) {
        maxTotalSize = Number.MAX_VALUE;
      }
      var includeDir = attrGetter('ngfIncludeDir', scope);
      var files = [], totalSize = 0;

      function traverseFileTree(entry, path) {
        var defer = $q.defer();
        if (entry != null) {
          if (entry.isDirectory) {
            var promises = [upload.emptyPromise()];
            if (includeDir) {
              var file = {type: 'directory'};
              file.name = file.path = (path || '') + entry.name;
              files.push(file);
            }
            var dirReader = entry.createReader();
            var entries = [];
            var readEntries = function () {
              dirReader.readEntries(function (results) {
                try {
                  if (!results.length) {
                    angular.forEach(entries.slice(0), function (e) {
                      if (files.length <= maxFiles && totalSize <= maxTotalSize) {
                        promises.push(traverseFileTree(e, (path ? path : '') + entry.name + '/'));
                      }
                    });
                    $q.all(promises).then(function () {
                      defer.resolve();
                    }, function (e) {
                      defer.reject(e);
                    });
                  } else {
                    entries = entries.concat(Array.prototype.slice.call(results || [], 0));
                    readEntries();
                  }
                } catch (e) {
                  defer.reject(e);
                }
              }, function (e) {
                defer.reject(e);
              });
            };
            readEntries();
          } else {
            entry.file(function (file) {
              try {
                file.path = (path ? path : '') + file.name;
                if (includeDir) {
                  file = upload.rename(file, file.path);
                }
                files.push(file);
                totalSize += file.size;
                defer.resolve();
              } catch (e) {
                defer.reject(e);
              }
            }, function (e) {
              defer.reject(e);
            });
          }
        }
        return defer.promise;
      }

      var promises = [upload.emptyPromise()];

      if (items && items.length > 0 && $window.location.protocol !== 'file:') {
        for (var i = 0; i < items.length; i++) {
          if (items[i].webkitGetAsEntry && items[i].webkitGetAsEntry() && items[i].webkitGetAsEntry().isDirectory) {
            var entry = items[i].webkitGetAsEntry();
            if (entry.isDirectory && !allowDir) {
              continue;
            }
            if (entry != null) {
              promises.push(traverseFileTree(entry));
            }
          } else {
            var f = items[i].getAsFile();
            if (f != null) {
              files.push(f);
              totalSize += f.size;
            }
          }
          if (files.length > maxFiles || totalSize > maxTotalSize ||
            (!multiple && files.length > 0)) break;
        }
      } else {
        if (fileList != null) {
          for (var j = 0; j < fileList.length; j++) {
            var file = fileList.item(j);
            if (file.type || file.size > 0) {
              files.push(file);
              totalSize += file.size;
            }
            if (files.length > maxFiles || totalSize > maxTotalSize ||
              (!multiple && files.length > 0)) break;
          }
        }
      }

      var defer = $q.defer();
      $q.all(promises).then(function () {
        if (!multiple && !includeDir && files.length) {
          var i = 0;
          while (files[i] && files[i].type === 'directory') i++;
          defer.resolve([files[i]]);
        } else {
          defer.resolve(files);
        }
      }, function (e) {
        defer.reject(e);
      });

      return defer.promise;
    }
  }

  function dropAvailable() {
    var div = document.createElement('div');
    return ('draggable' in div) && ('ondrop' in div) && !/Edge\/12./i.test(navigator.userAgent);
  }

})();

// customized version of https://github.com/exif-js/exif-js
ngFileUpload.service('UploadExif', ['UploadResize', '$q', function (UploadResize, $q) {
  var upload = UploadResize;

  upload.isExifSupported = function () {
    return window.FileReader && new FileReader().readAsArrayBuffer && upload.isResizeSupported();
  };

  function applyTransform(ctx, orientation, width, height) {
    switch (orientation) {
      case 2:
        return ctx.transform(-1, 0, 0, 1, width, 0);
      case 3:
        return ctx.transform(-1, 0, 0, -1, width, height);
      case 4:
        return ctx.transform(1, 0, 0, -1, 0, height);
      case 5:
        return ctx.transform(0, 1, 1, 0, 0, 0);
      case 6:
        return ctx.transform(0, 1, -1, 0, height, 0);
      case 7:
        return ctx.transform(0, -1, -1, 0, height, width);
      case 8:
        return ctx.transform(0, -1, 1, 0, 0, width);
    }
  }

  upload.readOrientation = function (file) {
    var defer = $q.defer();
    var reader = new FileReader();
    var slicedFile = file.slice ? file.slice(0, 64 * 1024) : file;
    reader.readAsArrayBuffer(slicedFile);
    reader.onerror = function (e) {
      return defer.reject(e);
    };
    reader.onload = function (e) {
      var result = {orientation: 1};
      var view = new DataView(this.result);
      if (view.getUint16(0, false) !== 0xFFD8) return defer.resolve(result);

      var length = view.byteLength,
        offset = 2;
      while (offset < length) {
        var marker = view.getUint16(offset, false);
        offset += 2;
        if (marker === 0xFFE1) {
          if (view.getUint32(offset += 2, false) !== 0x45786966) return defer.resolve(result);

          var little = view.getUint16(offset += 6, false) === 0x4949;
          offset += view.getUint32(offset + 4, little);
          var tags = view.getUint16(offset, little);
          offset += 2;
          for (var i = 0; i < tags; i++)
            if (view.getUint16(offset + (i * 12), little) === 0x0112) {
              var orientation = view.getUint16(offset + (i * 12) + 8, little);
              if (orientation >= 2 && orientation <= 8) {
                view.setUint16(offset + (i * 12) + 8, 1, little);
                result.fixedArrayBuffer = e.target.result;
              }
              result.orientation = orientation;
              return defer.resolve(result);
            }
        } else if ((marker & 0xFF00) !== 0xFF00) break;
        else offset += view.getUint16(offset, false);
      }
      return defer.resolve(result);
    };
    return defer.promise;
  };

  function arrayBufferToBase64(buffer) {
    var binary = '';
    var bytes = new Uint8Array(buffer);
    var len = bytes.byteLength;
    for (var i = 0; i < len; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return window.btoa(binary);
  }

  upload.applyExifRotation = function (file) {
    if (file.type.indexOf('image/jpeg') !== 0) {
      return upload.emptyPromise(file);
    }

    var deferred = $q.defer();
    upload.readOrientation(file).then(function (result) {
      if (result.orientation < 2 || result.orientation > 8) {
        return deferred.resolve(file);
      }
      upload.dataUrl(file, true).then(function (url) {
        var canvas = document.createElement('canvas');
        var img = document.createElement('img');

        img.onload = function () {
          try {
            canvas.width = result.orientation > 4 ? img.height : img.width;
            canvas.height = result.orientation > 4 ? img.width : img.height;
            var ctx = canvas.getContext('2d');
            applyTransform(ctx, result.orientation, img.width, img.height);
            ctx.drawImage(img, 0, 0);
            var dataUrl = canvas.toDataURL(file.type || 'image/WebP', 0.934);
            dataUrl = upload.restoreExif(arrayBufferToBase64(result.fixedArrayBuffer), dataUrl);
            var blob = upload.dataUrltoBlob(dataUrl, file.name);
            deferred.resolve(blob);
          } catch (e) {
            return deferred.reject(e);
          }
        };
        img.onerror = function () {
          deferred.reject();
        };
        img.src = url;
      }, function (e) {
        deferred.reject(e);
      });
    }, function (e) {
      deferred.reject(e);
    });
    return deferred.promise;
  };

  upload.restoreExif = function (orig, resized) {
    var ExifRestorer = {};

    ExifRestorer.KEY_STR = 'ABCDEFGHIJKLMNOP' +
      'QRSTUVWXYZabcdef' +
      'ghijklmnopqrstuv' +
      'wxyz0123456789+/' +
      '=';

    ExifRestorer.encode64 = function (input) {
      var output = '',
        chr1, chr2, chr3 = '',
        enc1, enc2, enc3, enc4 = '',
        i = 0;

      do {
        chr1 = input[i++];
        chr2 = input[i++];
        chr3 = input[i++];

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;

        if (isNaN(chr2)) {
          enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
          enc4 = 64;
        }

        output = output +
          this.KEY_STR.charAt(enc1) +
          this.KEY_STR.charAt(enc2) +
          this.KEY_STR.charAt(enc3) +
          this.KEY_STR.charAt(enc4);
        chr1 = chr2 = chr3 = '';
        enc1 = enc2 = enc3 = enc4 = '';
      } while (i < input.length);

      return output;
    };

    ExifRestorer.restore = function (origFileBase64, resizedFileBase64) {
      if (origFileBase64.match('data:image/jpeg;base64,')) {
        origFileBase64 = origFileBase64.replace('data:image/jpeg;base64,', '');
      }

      var rawImage = this.decode64(origFileBase64);
      var segments = this.slice2Segments(rawImage);

      var image = this.exifManipulation(resizedFileBase64, segments);

      return 'data:image/jpeg;base64,' + this.encode64(image);
    };


    ExifRestorer.exifManipulation = function (resizedFileBase64, segments) {
      var exifArray = this.getExifArray(segments),
        newImageArray = this.insertExif(resizedFileBase64, exifArray);
      return new Uint8Array(newImageArray);
    };


    ExifRestorer.getExifArray = function (segments) {
      var seg;
      for (var x = 0; x < segments.length; x++) {
        seg = segments[x];
        if (seg[0] === 255 & seg[1] === 225) //(ff e1)
        {
          return seg;
        }
      }
      return [];
    };


    ExifRestorer.insertExif = function (resizedFileBase64, exifArray) {
      var imageData = resizedFileBase64.replace('data:image/jpeg;base64,', ''),
        buf = this.decode64(imageData),
        separatePoint = buf.indexOf(255, 3),
        mae = buf.slice(0, separatePoint),
        ato = buf.slice(separatePoint),
        array = mae;

      array = array.concat(exifArray);
      array = array.concat(ato);
      return array;
    };


    ExifRestorer.slice2Segments = function (rawImageArray) {
      var head = 0,
        segments = [];

      while (1) {
        if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 218) {
          break;
        }
        if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 216) {
          head += 2;
        }
        else {
          var length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3],
            endPoint = head + length + 2,
            seg = rawImageArray.slice(head, endPoint);
          segments.push(seg);
          head = endPoint;
        }
        if (head > rawImageArray.length) {
          break;
        }
      }

      return segments;
    };


    ExifRestorer.decode64 = function (input) {
      var chr1, chr2, chr3 = '',
        enc1, enc2, enc3, enc4 = '',
        i = 0,
        buf = [];

      // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
      var base64test = /[^A-Za-z0-9\+\/\=]/g;
      if (base64test.exec(input)) {
        console.log('There were invalid base64 characters in the input text.\n' +
          'Valid base64 characters are A-Z, a-z, 0-9, ' + ', ' / ',and "="\n' +
          'Expect errors in decoding.');
      }
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');

      do {
        enc1 = this.KEY_STR.indexOf(input.charAt(i++));
        enc2 = this.KEY_STR.indexOf(input.charAt(i++));
        enc3 = this.KEY_STR.indexOf(input.charAt(i++));
        enc4 = this.KEY_STR.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        buf.push(chr1);

        if (enc3 !== 64) {
          buf.push(chr2);
        }
        if (enc4 !== 64) {
          buf.push(chr3);
        }

        chr1 = chr2 = chr3 = '';
        enc1 = enc2 = enc3 = enc4 = '';

      } while (i < input.length);

      return buf;
    };

    return ExifRestorer.restore(orig, resized);  //<= EXIF
  };

  return upload;
}]);


window.Util = (function() {
    "use strict";

    var graceWestCampusAddress = {
        line1: "2695 Creve Coeur Mill Rd",
        city: "Maryland Heights",
        state: "MO",
        zip: 63043
    };

    var graceEastCampusAddress = {
        line1: "4701 State Route 111",
        city: "Granite City",
        state: "IL",
        zip: 62040
    };
    
    return {
        authenticate: ["$rootScope", "$q", "graceGroupsService", authenticate],
        authenticateAdmin: ["$rootScope", "$q", "graceGroupsService", authenticateAdmin],
        graceWestAddress: graceWestCampusAddress,
        graceEastAddress: graceEastCampusAddress,
        isGraceWestCampus: isGraceWestCampus,
        isGraceEastCampus: isGraceEastCampus,
        alert: alert,
        downloadContent: downloadContent,
        isEmpty: isEmpty,
        externalUrl: externalUrl,
        isTouchDevice: isTouchDevice,
        genGuid: genGuid
    };

    function authenticate($rootScope, $q, service) {
        if ($rootScope.user) {
            return $q(function(resolve) {
                resolve($rootScope.user);
            });
        } else {
            return $q(function(resolve) {
                service.currentUser().then(function(user) {
                    $rootScope.user = user;
                    resolve(user);
                }, function(err) {
                    if (err === 'no-auth') {
                        $rootScope.setStateAfterLogin();
                        $rootScope.$state.go('login');
                    } else {
                        $rootScope.$state.go('error');
                    }
                    resolve(null);
                })
            });
        }
    }

    function authenticateAdmin($rootScope, $q, service) {
        return authenticate($rootScope, $q, service).then(function(user) {
            if (user !== null && !user.admin) {
                console.log("unauthorized access");
                $rootScope.$state.go('error');
                return null;
            }
            return user;
        });
    }

    function isGraceWestCampus(address) {
        return address.line1 === graceWestCampusAddress.line1 &&
                address.city === graceWestCampusAddress.city &&
                address.state === graceWestCampusAddress.state &&
                address.zip === graceWestCampusAddress.zip;
    }
    
    function isGraceEastCampus(address) {
        return address.line1 === graceEastCampusAddress.line1 &&
            address.city === graceEastCampusAddress.city &&
            address.state === graceEastCampusAddress.state &&
            address.zip === graceEastCampusAddress.zip;
    }
    
    function alert(msg, title) {
        var $errorModal = $("#errorModal");
        $errorModal.find(".modal-body").html(msg);
        $errorModal.find(".modal-title").text(title || 'Error');
        $errorModal.modal("show");
    }

    function downloadContent(content, mimeType, fileName) {
        var a = document.createElement('a');

        if (navigator.msSaveBlob) { // IE10
            return navigator.msSaveBlob(new Blob([content], {type: mimeType}), fileName);
        } else if ('download' in a) { //html5 A[download]
            a.href = 'data:' + mimeType + ',' + encodeURIComponent(content);
            a.setAttribute('download', fileName);
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            return true;
        } else { //do iframe dataURL download (old ch+FF):
            var f = document.createElement('iframe');
            document.body.appendChild(f);
            f.src = 'data:' + mimeType + ',' + encodeURIComponent(content);

            setTimeout(function () {
                document.body.removeChild(f);
            }, 333);
            return true;
        }
    }

    function isEmpty(val) {
        return val === undefined || val === null || val === "";
    }

    function externalUrl(url, secure) {
        if (url.indexOf("http") !== 0) {
            var protocol = secure ? "https://" : "http://";
            return protocol + url;
        } else {
            return url;
        }
    }

    function isTouchDevice() {
        return 'ontouchstart' in window        // works on most browsers
            || navigator.maxTouchPoints;       // works on IE10/11 and Surface
    }

    function genGuid() {
        return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
            s4() + '-' + s4() + s4() + s4();
    }
    function s4() {
        return Math.floor((1 + Math.random()) * 0x10000)
            .toString(16)
            .substring(1);
    }

})();

angular.module('angularPromiseButtons', []);

angular.module('angularPromiseButtons')
    .directive('promiseBtn', ['angularPromiseButtons', '$parse', '$timeout', '$compile', function(angularPromiseButtons, $parse, $timeout, $compile) {
        'use strict';

        return {
            restrict: 'EA',
            priority: angularPromiseButtons.config.priority,
            scope: {
                promiseBtn: '=',
                promiseBtnOptions: '=?'
            },
            link: function(scope, el, attrs) {
                console.log("in link");
                // provide configuration
                var cfg = angularPromiseButtons.config;
                // later initialized via initPromiseWatcher()
                var promiseWatcher;
                //  timeout used
                var minDurationTimeout;
                // boolean to determine minDurationTimeout state
                var minDurationTimeoutDone;
                // boolean to determine if promise was resolved
                var promiseDone;


                /**
                 * Handles everything to be triggered when the button is set
                 * to loading state.
                 * @param {Object}btnEl
                 */
                function initLoadingState(btnEl) {
                    console.log('in init loading state');
                    if (cfg.btnLoadingClass && !cfg.addClassToCurrentBtnOnly) {
                        btnEl.addClass(cfg.btnLoadingClass);
                    }
                    if (cfg.disableBtn && !cfg.disableCurrentBtnOnly) {
                        btnEl.attr('disabled', 'disabled');
                    }
                }

                /**
                 * Handles everything to be triggered when loading is finished
                 * @param {Object}btnEl
                 */
                function handleLoadingFinished(btnEl) {
                    if ((!cfg.minDuration || minDurationTimeoutDone) && promiseDone) {
                        if (cfg.btnLoadingClass) {
                            btnEl.removeClass(cfg.btnLoadingClass);
                        }
                        if (cfg.disableBtn) {
                            btnEl.removeAttr('disabled');
                        }
                    }
                }

                /**
                 * Initializes a watcher for the promise. Also takes
                 * cfg.minDuration into account if given.
                 * @param {Function}watchExpressionForPromise
                 * @param {Object}btnEl
                 */
                function initPromiseWatcher(watchExpressionForPromise, btnEl) {
                    // watch promise to resolve or fail
                    scope.$watch(watchExpressionForPromise, function(mVal) {
                        minDurationTimeoutDone = false;
                        promiseDone = false;

                        // create timeout if option is set
                        if (cfg.minDuration) {
                            minDurationTimeout = $timeout(function() {
                                minDurationTimeoutDone = true;
                                handleLoadingFinished(btnEl);
                            }, cfg.minDuration);
                        }

                        // for regular promises
                        if (mVal && mVal.then) {
                            initLoadingState(btnEl);
                            mVal.finally(function() {
                                promiseDone = true;
                                handleLoadingFinished(btnEl);
                            });
                        }
                        // for $resource
                        else if (mVal && mVal.$promise) {
                            initLoadingState(btnEl);
                            mVal.$promise.finally(function() {
                                promiseDone = true;
                                handleLoadingFinished(btnEl);
                            });
                        }
                    });
                }


                /**
                 * Get the callbacks from the (String) expression given.
                 * @param {String}expression
                 * @returns {Array}
                 */
                function getCallbacks(expression) {
                    return expression
                    // split by ; to get different functions if any
                        .split(';')
                        .map(function(callback) {
                            // return getter function
                            return $parse(callback);
                        });
                }

                /**
                 * $compile and append the spinner template to the button.
                 * @param {Object}btnEl
                 */
                function appendSpinnerTpl(btnEl) {
                    btnEl.append($compile(cfg.spinnerTpl)(scope));
                }

                /**
                 * Used to limit loading state to show only for the currently
                 * clicked button.
                 * @param {Object}btnEl
                 */
                function addHandlersForCurrentBtnOnly(btnEl) {
                    // handle current button only options via click
                    if (cfg.addClassToCurrentBtnOnly) {
                        btnEl.on(cfg.CLICK_EVENT, function() {
                            btnEl.addClass(cfg.btnLoadingClass);
                        });
                    }

                    if (cfg.disableCurrentBtnOnly) {
                        btnEl.on(cfg.CLICK_EVENT, function() {
                            btnEl.attr('disabled', 'disabled');
                        });
                    }
                }

                /**
                 * Used for the function syntax of the promise button directive by
                 * parsing the expressions provided by the attribute via getCallbacks().
                 * Unbinds the default event handlers, which is why it might sometimes
                 * be required to use the promise syntax.
                 * @param {Object}eventToHandle
                 * @param {String}attrToParse
                 * @param {Object}btnEl
                 */
                function initHandlingOfViewFunctionsReturningAPromise(eventToHandle, attrToParse, btnEl) {
                    // we need to use evalAsync here, as
                    // otherwise the click or submit event
                    // won't be ready to be replaced
                    scope.$evalAsync(function() {
                        var callbacks = getCallbacks(attrs[attrToParse]);

                        // unbind original click event
                        el.unbind(eventToHandle);

                        // rebind, but this time watching it's return value
                        el.bind(eventToHandle, function() {
                            // Make sure we run the $digest cycle
                            scope.$apply(function() {
                                callbacks.forEach(function(cb) {
                                    // execute function on parent scope
                                    // as we're in an isolate scope here
                                    var promise = cb(scope.$parent, {$event: eventToHandle});

                                    // only init watcher if not done before
                                    if (!promiseWatcher) {
                                        promiseWatcher = initPromiseWatcher(function() {
                                            return promise;
                                        }, btnEl);
                                    }
                                });
                            });
                        });
                    });
                }

                /**
                 * Get's all submit button children of the given element
                 * @param {Object}formEl
                 * @returns {Object}
                 */
                function getSubmitBtnChildren(formEl) {
                    var submitBtnEls = [];
                    var allButtonEls = formEl.find('button');

                    for (var i = 0; i < allButtonEls.length; i++) {
                        var btnEl = allButtonEls[i];
                        if (angular.element(btnEl)
                                .attr('type') === 'submit') {
                            submitBtnEls.push(btnEl);
                        }
                    }
                    return angular.element(submitBtnEls);
                }


                // INIT
                // ---------

                // check if there is any value given via attrs.promiseBtn
                if (!attrs.promiseBtn) {
                    console.log('no specific promise');
                    // handle ngClick function directly returning a promise
                    if (attrs.hasOwnProperty(cfg.CLICK_ATTR)) {
                        appendSpinnerTpl(el);
                        addHandlersForCurrentBtnOnly(el);
                        initHandlingOfViewFunctionsReturningAPromise(cfg.CLICK_EVENT, cfg.CLICK_ATTR, el);
                    }
                    // handle ngSubmit function directly returning a promise
                    else if (attrs.hasOwnProperty(cfg.SUBMIT_ATTR)) {
                        // get child submits for form elements
                        var btnElements = getSubmitBtnChildren(el);

                        appendSpinnerTpl(btnElements);
                        addHandlersForCurrentBtnOnly(btnElements);
                        initHandlingOfViewFunctionsReturningAPromise(cfg.SUBMIT_EVENT, cfg.SUBMIT_ATTR, btnElements);
                    }
                }
                // handle promises passed via scope.promiseBtn
                else {
                    console.log('specific promise');
                    appendSpinnerTpl(el);
                    addHandlersForCurrentBtnOnly(el);
                    // handle promise passed directly via attribute as variable
                    initPromiseWatcher(function() {
                        return scope.promiseBtn;
                    }, el);
                }


                // watch and update options being changed
                scope.$watch('promiseBtnOptions', function(newVal) {
                    if (angular.isObject(newVal)) {
                        cfg = angular.extend({}, cfg, newVal);
                    }
                }, true);

                // cleanup
                scope.$on('$destroy', function() {
                    $timeout.cancel(minDurationTimeout);
                });
            }
        };
    }]);

angular.module('angularPromiseButtons')
    .provider('angularPromiseButtons', function angularPromiseButtonsProvider() {
        'use strict';

        // *****************
        // DEFAULTS & CONFIG
        // *****************

        var config = {
            spinnerTpl: '<span class="btn-spinner"></span>',
            priority: 0,
            disableBtn: true,
            btnLoadingClass: 'is-loading',
            addClassToCurrentBtnOnly: false,
            disableCurrentBtnOnly: false,
            minDuration: false,
            CLICK_EVENT: 'click',
            CLICK_ATTR: 'ngClick',
            SUBMIT_EVENT: 'submit',
            SUBMIT_ATTR: 'ngSubmit'
        };

        // *****************
        // SERVICE-FUNCTIONS
        // *****************


        // *************************
        // PROVIDER-CONFIG-FUNCTIONS
        // *************************

        return {
            extendConfig: function(newConfig) {
                config = angular.extend(config, newConfig);
            },


            // ************************************************
            // ACTUAL FACTORY FUNCTION - used by the directive
            // ************************************************

            $get: function() {
                return {
                    config: config
                };
            }
        };
    });

(function(angular) {

    //TODO JQ: gzip images if it is not something that Rob would need to do
    //TODO JQ: consider resizing uploaded images for performance reasons
    //TODO JQ: create a README so I don't forget how to run and deploy this thing
    //TODO JQ: clean out the on-members stuff that is not used anymore
    //TODO JQ: don't return full address from the server
    //TODO JQ: color code the alerts (success=green, error=red, info=black)

    //TODO JQ: add a my managers section to user details
    //TODO JQ: organize the my groups section: leader of, member of, manager of
    //TODO JQ: make the group view on the usr details page smaller maybe? ... at least for the manager of part

    // LONG TERM WISH LIST
    //TODO JQ: add an org structure page
    //TODO JQ: don't use the view components on the details page
    //TODO JQ: remember search criteria and pages requested on going to listing pages
    //TODO JQ: automated tests
    //TODO JQ: google map
    //TODO JQ: add a role type to the user search
    //TODO JQ: delete user from user details screen

    // REGRESSION TEST PLAN
    //   create a user
    //   log in with that user
    //   upload a photo
    //   create a group
    //   add members to group (new and existing users)
    //   remove members from the group
    //   create two meeting reports
    //   delete one of the reports
    //   log in with admin
    //   approve the group
    //   try to delete the new contact (should not allow)
    //   remove the contact from the group
    //   confirm meeting report shows them as a guest now
    //   delete the contact
    //   confirm meeting report shows them as a guest still
    //   edit the meeting report in some way
    //   try to delete the user (should not allow)
    //   change leader of the new group
    //   delete the user
    //   delete the group

    'use strict';

    angular.module('grace-groups', ['gg.common', 'groups', 'graceGroupsService', 'authorizer']);

    angular.module('grace-groups-admin', ['ngFileUpload', 'gg.common', 'ui.router', 'users', 'groups', 'meetingReports', 'graceGroupsService', 'authorizer', 'ngConstants'])
        .config(["$stateProvider", "$urlRouterProvider", "partialPath", function ($stateProvider, $urlRouterProvider, partialPath) {
            $urlRouterProvider.otherwise("/users/home");
            
            $stateProvider
                .state('login', {
                    url: "/login",
                    templateUrl: partialPath + "/login-form.html",
                    controller: ["$rootScope", "graceGroupsService", "$location", "$window", "secureCookies", LoginController],
                    controllerAs: "$ctrl"
                })
            
                .state("error", {
                    templateUrl: partialPath + "/error.html"
                })
        }])
        
        .run(["$rootScope", "$state", "$stateParams", "authorizer", function($rootScope, $state, $stateParams, authorizer) {
            $rootScope.$state = $state;
            $rootScope.$stateParams = $stateParams;
            $rootScope.authorizer = authorizer;

            $rootScope.$on('$stateChangeError', function(event, toState, toParams, fromState, fromParams, error) {
                event.preventDefault();
                console.log("something went wrong - ", error);
                $state.go('error');
            });

            $rootScope.$on('$stateChangeSuccess', function() {
                var toggle = $('.navbar-toggle');
                if (!toggle.hasClass("collapsed")) {
                    toggle.click();
                }
            });

            $rootScope.$on('$stateChangeStart', function(e, toState, toParams) {
                console.log("state change start", toState);
                $rootScope.requestedState = {name: toState.name, params: $.extend({}, toParams)};
            });
            
            $rootScope.setGroupEditReturnToState = function() {
                $rootScope.groupEditReturnToState = {name: $state.current.name, params: $.extend({}, $stateParams)};
            };

            $rootScope.goToGroupEditReturnToState = function() {
                if ($rootScope.groupEditReturnToState !== undefined) {
                    $state.go($rootScope.groupEditReturnToState.name, $rootScope.groupEditReturnToState.params);
                } else {
                    $state.go("groups.index");
                }
                $rootScope.groupEditReturnToState = undefined;
            };
            
            $rootScope.setUserEditReturnToState = function() {
                $rootScope.userEditReturnToState = {name: $state.current.name, params: $.extend({}, $stateParams)};
            };
            
            $rootScope.goToUserEditReturnToState = function() {
                if ($rootScope.userEditReturnToState !== undefined) {
                    $state.go($rootScope.userEditReturnToState.name, $rootScope.userEditReturnToState.params);
                } else {
                    $state.go("users.home");
                }
                $rootScope.userEditReturnToState = undefined;
            };

            $rootScope.setGroupMemberReturnToState = function() {
                $rootScope.groupMemberReturnToState = {name: $state.current.name, params: $.extend({}, $stateParams)};
            };

            $rootScope.goToGroupMemberReturnToState = function() {
                if ($rootScope.groupMemberReturnToState !== undefined) {
                    $state.go($rootScope.groupMemberReturnToState.name, $rootScope.groupMemberReturnToState.params);
                } else {
                    $state.go("groups.index");
                }
                $rootScope.groupMemberReturnToState = undefined;
            };

            $rootScope.setStateAfterLogin = function() {
                $rootScope.stateAfterLogin = $rootScope.requestedState;
            };

            $rootScope.goToStateAfterLoginOr = function(defaultStateName) {
                console.log("state after login", $rootScope.stateAfterLogin);
                if ($rootScope.stateAfterLogin !== undefined) {
                    $state.go($rootScope.stateAfterLogin.name, $rootScope.stateAfterLogin.params);
                    $rootScope.stateAfterLogin = undefined;
                } else {
                    $state.go(defaultStateName);
                }
            };

            $rootScope.hasError = function(element) {
                console.log("does it have an error", element.$invalid);
                return false;
            };
                
        }])

        .component("ggNav", {
            templateUrl: ["partialPath", function(partialPath) {return partialPath + "/nav.html";}],
            controller: ["graceGroupsService", "$rootScope", "$state", "$stateParams", NavController]
        })

        .directive("compareTo", function() {
            return {
                require: "ngModel",
                scope: {
                    otherModelValue: "=compareTo"
                },
                link: function (scope, element, attribute, ngModel) {
                    ngModel.$validators.compareTo = function (modelValue) {
                        return modelValue === scope.otherModelValue;
                    };

                    scope.$watch("otherModelValue", function () {
                        ngModel.$validate();
                    });
                }
            };
        })

        .directive("notEqualTo", function() {
            return {
                require: "ngModel",
                scope: {
                    otherModelValue: "=notEqualTo"
                },
                link: function (scope, element, attribute, ngModel) {
                    ngModel.$validators.notEqualTo = function (modelValue) {
                        if (modelValue === undefined || modelValue === "") {
                            return true;
                        } else {
                            return modelValue !== scope.otherModelValue;
                        }
                    };

                    scope.$watch("otherModelValue", function () {
                        ngModel.$validate();
                    });
                }
            };
        })

        .directive("timeAfter", function() {
            return {
                require: "ngModel",
                scope: {
                    otherModelValue: "=timeAfter"
                },
                link: function (scope, element, attribute, ngModel) {
                    ngModel.$validators.timeAfter = function (modelValue) {
                        if (scope.otherModelValue === null) {
                            return true;
                        }
                        return moment(modelValue).isSameOrAfter(moment(scope.otherModelValue));
                    };

                    scope.$watch("otherModelValue", function () {
                        ngModel.$validate();
                    });
                }
            };
        })

        .directive("requiredIfNotOther", function() {
            return {
                require: "ngModel",
                scope: {
                    otherModelValue: "=requiredIfNotOther"
                },
                link: function (scope, element, attribute, ngModel) {
                    ngModel.$validators.requiredIfNotOther = function (modelValue) {
                        return !(Util.isEmpty(scope.otherModelValue) && Util.isEmpty(modelValue));
                    };

                    scope.$watch("otherModelValue", function () {
                        ngModel.$validate();
                    });
                }
            };
        })

        .directive("serverValidation", function() {
            return {
                require: "ngModel",
                link: function (scope, element, attribute, ngModel) {
                    ngModel.$validators.serverValidation = function() {
                        return true;
                    };
                }
            };
        })

        .filter("filterByUserName", function() {return filterByUserName;})
        .filter("hasError", function() {return hasError;})

        .directive("scrollPos", ["$state", "$window", "$timeout", "$location", "$anchorScroll", function($state, $window, $timeout, $location, $anchorScroll) {
            // cache scroll position of each state's templateUrl
            var scrollPosCache = {};

            // compile function
            return function(scope, element, attrs) {

                scope.$on('$stateChangeStart', function() {
                    if (attrs.scrollPos === 'keep') {
                        // store scroll position for the current view
                        if ($state.current) {
                            console.log($state.current.templateUrl);
                            scrollPosCache[$state.current.templateUrl] = [$window.pageXOffset, $window.pageYOffset];
                        }
                    }
                });

                scope.$on('$stateChangeSuccess', function() {
                    // if hash is specified explicitly, it trumps previously stored scroll position
                    if ($location.hash()) {
                        $anchorScroll();
                        // else get previous scroll position; if none, scroll to the top of the page
                    } else {
                        var prevScrollPos = scrollPosCache[$state.current.templateUrl] || [ 0, 0 ];
                        $timeout(function() {
                            $window.scrollTo(prevScrollPos[0], prevScrollPos[1]);
                        }, 100);
                    }
                });
            }
        }]);

    function LoginController($rootScope, service, $location, $window, secureCookies) {
        if (secureCookies && $location.protocol() !== 'https') {
            $window.location.href = $location.absUrl().replace('http', 'https');
        }

        var self = this;
        self.email = "";
        self.password = "";

        self.login = function() {
            service.login({email: self.email, password: self.password}).then(function(user) {
                $rootScope.user = user;
                $rootScope.goToStateAfterLoginOr("users.home");
            }, function(error) {
                $rootScope.user = null;
                if (error === "invalid-login") {
                    self.invalidLogin = true;
                } else {
                    Util.alert("Login failed. Please try again.");
                }
            });
        };
    }
    
    function NavController(service, $rootScope, $state, $stateParams) {
        var self = this;
        
        self.logout = function() {
            service.logout();
            $rootScope.user = null;
            $state.go("login");
        };

        self.isProfilePage = function() {
            return $state.includes("users.home") || ($state.includes("users.details") && $rootScope.user && $rootScope.user.id === $stateParams["id"]);
        };
    }

    function filterByUserName(users, firstName, lastName) {
        return users.filter(function(user) {
            var firstNameMatch = !provided(firstName) || user.firstName.toLowerCase().indexOf(firstName.toLowerCase()) >= 0;
            var lastNameMatch = !provided(lastName) || user.lastName.toLowerCase().indexOf(lastName.toLowerCase()) >= 0;
            return firstNameMatch && lastNameMatch;
        });

        function provided(filter) {
            return filter !== undefined && filter !== null && filter.trim() !== "";
        }
    }
    
})(window.angular);

(function(angular) {
    'use strict';

    angular.module('gg.common', ['ngConstants', 'ui.router', 'users'])
        .filter("enumToLabel", function() {return enumToLabel;})

        .filter('leaderMailTo', function() {
            return function(group, subject) {
                return "mailto:" +
                    group.leader.email + "?" +
                    (group.secondaryLeader !== null ? "cc=" + group.secondaryLeader.email + "&" : "") +
                    "subject=" + subject;
            };
        })

        .filter('mailToAll', function() {
            return function(users, subject) {
                if (users && users.length > 0) {
                    var emailAddresses = users.filter(function(u) { return u.email !== null; })
                        .map(function(u) { return u.email; });

                    if (emailAddresses.length > 0) {
                        var link = "mailto:" + emailAddresses.join(";") + "?subject=" + (subject || "");
                        console.log("mailto link", link);
                        return link;
                    }
                }
            };
        })

        .filter('orDefaultImage', ["imagesPath", function(imagesPath) {
            return function(image) {
                if (Util.isEmpty(image)) {
                    return imagesPath + "/noImage.png";
                } else {
                    return image;
                }
            };
        }])

        .directive("confirmBox", ["partialPath", function(partialPath) {
            return {
                restrict: "E",
                scope: {
                    title: "@",
                    noLabel: "@",
                    yesLabel: "@",
                    onNo: "&",
                    onYes: "&",
                    modalId: "@"
                },
                templateUrl: partialPath + "/confirm.html",
                transclude: true,
                link: ConfirmBoxController
            };
        }])

        .component("auditInfo", {
            templateUrl: ["partialPath", function(partialPath) {return partialPath + "/audit-info.html";}],
            bindings: {
                model: "<"
            }
        })

        .directive("imageChooser", ["partialPath", function(partialPath) {
            return {
                restrict: "E",
                scope: {
                    title: "@",
                    onClearImage: "&",
                    onSaveImage: "&",
                    modalId: "@",
                    currentImage: "="
                },
                templateUrl: partialPath + "/image-chooser.html",
                link: ImageChooserController
            };
        }]);

    function ConfirmBoxController(scope, element) {
        var modalElement = element.find(".modal");
        scope.noLabel = scope.noLabel || "Cancel";
        scope.yesLabel = scope.yesLabel || "Yes";
        scope.modalId = scope.modalId || "confirm";
        scope.yesClick = function() {
            console.log("clicked yes");
            modalElement.off("hidden.bs.modal").on("hidden.bs.modal", function() {scope.onYes();});
            modalElement.modal("hide");
        };
        scope.noClick = function() {
            console.log("clicked no");
            modalElement.off("hidden.bs.modal").on("hidden.bs.modal", function() {scope.onNo();});
            modalElement.modal("hide");
        };
    }

    function ImageChooserController(scope, element) {
        var modalElement = element.find(".modal");
        modalElement.on("show.bs.modal", reset);

        scope.unsupported = (typeof window.FormData === 'undefined');

        function reset() {
            scope.imageFile = null;
            scope.invalid = null;
            scope.clearImage = false;
            scope.$apply();
        }

        scope.modalId = scope.modalId || "image-chooser";
        scope.saveClick = function () {
            if (scope.clearImage) {
                modalElement.off("hidden.bs.modal").on("hidden.bs.modal", function () {
                    scope.onClearImage();
                });
            } else {
                modalElement.off("hidden.bs.modal").on("hidden.bs.modal", function () {
                    scope.onSaveImage({file: scope.imageFile});
                });
            }

            modalElement.modal("hide");
        };

        scope.none = function() {
            scope.clearImage = true;
            scope.imageFile = null;
        };

        scope.selected = function() {
            scope.clearImage = false;
        };
    }

    function enumToLabel(enumVal) {
        if (enumVal === "GRACE_HAVE_ROOM") return "Grace, room assigned";
        if (enumVal === "GRACE_NEED_ROOM") return "Grace, need room";
        if (enumVal === "CHILDCARE_PROVIDED") return "Provided";
        if (enumVal === "SINGLES_AND_COUPLES") return "Mixed single and married";
        if (enumVal === "MARRIEDS") return "Married";
        if (enumVal === "SINGLES") return "Single";
        return S(enumVal).humanize().s;
    }

})(window.angular);

(function(angular) {
    'use strict';

    angular.module('users', ['ui.router', "angularPromiseButtons", "ngConstants"])
        .config(["$stateProvider", "partialPath", function ($stateProvider, partialPath) {
            //noinspection JSUnusedGlobalSymbols
            $stateProvider
                .state("users", {
                    url: "/users",
                    abstract: true,
                    template: "<ui-view></ui-view>",
                    resolve: {
                        authUser: Util.authenticate
                    }
                })
                .state("users.index", {
                    url: "",
                    templateUrl: partialPath + "/users/index.html",
                    resolve: {
                        limit: function() {return 10;},
                        users: ["graceGroupsService", "limit", function(service, limit) {
                            return service.usersByName("", "", 0, limit);
                        }],
                        totalCount: ["graceGroupsService", function(service) {
                            return service.countUsersByName("", "");
                        }]
                    },
                    controller: ["graceGroupsService", "users", "totalCount", "limit", "$rootScope", UserIndexController],
                    controllerAs: "$ctrl"
                })
                .state("users.edit", {
                    url: "/{id:int}/edit",
                    templateUrl: partialPath + "/users/edit.html",
                    resolve: {
                        user: ["graceGroupsService", "$stateParams", "authUser", function(service, $stateParams) {
                            return service.user($stateParams["id"]);
                        }],
                        managers: ["graceGroupsService", "authUser", function(service) {
                            return service.managers();
                        }]
                    },
                    controller: ["user", "managers", "$rootScope", "graceGroupsService", EditUserController],
                    controllerAs: "$ctrl"
                })
                .state("users.editAndChangePassword", {
                    url: "/{id:int}/editAndChangePassword",
                    templateUrl: partialPath + "/users/edit.html",
                    resolve: {
                        user: ["graceGroupsService", "$stateParams", "authUser", function(service, $stateParams) {
                            return service.user($stateParams["id"]);
                        }],
                        managers: ["graceGroupsService", "authUser", function(service) {
                            return service.managers();
                        }],
                        changePassword: function() {return true;}
                    },
                    controller: ["user", "managers", "$rootScope", "graceGroupsService", "changePassword", EditUserController],
                    controllerAs: "$ctrl"
                })
                .state("users.details", {
                    url: "/{id:int}/details",
                    templateUrl: partialPath + "/users/details.html",
                    resolve: {
                        user: ["graceGroupsService", "$stateParams", function(service, $stateParams) {
                            return service.user($stateParams["id"]);
                        }],
                        groups: ["graceGroupsService", "$stateParams", function(service, $stateParams) {
                            return service.groupsForUser($stateParams["id"]);
                        }],
                        directReports: ["graceGroupsService", "$stateParams", function(service, $stateParams) {
                            return service.directReports($stateParams["id"]);
                        }],
                        show: ["$stateParams", function($stateParams) {
                            return $stateParams.show;
                        }]
                    },
                    controller: ["user", "authUser", "groups", "directReports", "$rootScope", "graceGroupsService", "show", UserDetailsController],
                    controllerAs: "$ctrl"
                })
                .state("users.home", {
                    url: "/home",
                    templateUrl: partialPath + "/users/details.html",
                    resolve: {
                        user: ["graceGroupsService", "authUser", function(service, authUser) {
                            return service.user(authUser.id);
                        }],
                        groups: ["graceGroupsService", "authUser", function(service, authUser) {
                            return service.groupsForUser(authUser.id);
                        }],
                        directReports: ["graceGroupsService", "authUser", function(service, authUser) {
                            return service.directReports(authUser.id);
                        }]
                    },
                    controller: ["user", "authUser", "groups", "directReports", "$rootScope", "graceGroupsService", UserDetailsController],
                    controllerAs: "$ctrl"
                })
                .state("users.new", {
                    url: "/new",
                    templateUrl: partialPath + "/users/new.html",
                    resolve: {
                        managers: ["graceGroupsService", function(service) {
                            return service.managers();
                        }]
                    },
                    controller: ["managers", NewUserController],
                    controllerAs: "$ctrl"
                });
        }])

        .component('ggUser', {
            templateUrl: ["partialPath", function(partialPath) { return partialPath + "/users/view.html"; }],
            bindings: {
                user: "<",
                hideRole: "@",
                onEdit: "&",
                showEdit: "<",
                onSelect: "&",
                showSelect: "<",
                onRemove: "&",
                showRemove: "<",
                confirmRemove: "<",
                badge: "<",
                deleteIcon: "@",
                highlight: "@",
                allowImageSelect: "<",
                compact: "<",
                noBorder: "<"
            },
            controller: ["graceGroupsService", UserController]
        })

        .component('ggUserForm', {
            templateUrl: ["partialPath", function(partialPath) { return partialPath + "/users/userForm.html"; }],
            bindings: {
                user: "<",
                onSave: "&",
                onCancel: "&",
                noRoleChange: "@",
                managers: "<",
                startWithChangePassword: "<"
            },
            controller: ["$rootScope", "graceGroupsService", "authorizer", UserFormController]
        });

    function UserIndexController(service, users, totalCount, limit, $rootScope) {
        var self = this;
        self.users = users;
        self.totalCount = totalCount;
        self.isFiltered = false;
        self.page = 0;

        $rootScope.setUserEditReturnToState();

        self.search = function() {
            return doSearch();
        };

        function doSearch(numberOfPages) {
            numberOfPages = (numberOfPages && numberOfPages > 0) ? numberOfPages : 1;
            var limitToUse = numberOfPages * limit;
            self.page = numberOfPages - 1;

            var searchPromise = service.usersByName(self.searchFirstNameText || "", self.searchLastNameText || "", 0, limitToUse).then(function(users) {
                self.users = users;
                self.isFiltered = (self.searchFirstNameText && self.searchFirstNameText !== "") || (self.searchLastNameText && self.searchLastNameText !== "");
            });
            service.countUsersByName(self.searchFirstNameText || "", self.searchLastNameText || "").then(function(count) {
                self.totalCount = count;
            });

            return searchPromise;
        }

        self.showMore = function() {
            self.page++;
            return service.usersByName(self.searchFirstNameText || "", self.searchLastNameText || "", self.page, limit).then(function(users) {
                Array.prototype.push.apply(self.users, users);
            });
        };

        self.showMoreCount = function() {
            var left = self.totalCount - self.users.length;
            return left > limit ? limit : left;
        };

        self.clearSearch = function() {
            self.searchFirstNameText = "";
            self.searchLastNameText = "";
            self.search();
        };

        self.noUsers = function() {
            return self.users.length === 0;
        };
        
        self.deleteUser = function(user) {
            service.deleteUser(user).then(function() {
                doSearch(self.page + 1);
            }, function(errors) {
                console.log(errors);
                var reasons = [];
                if (errors.indexOf("user-in-groups-not-deletable") >= 0) {
                    reasons.push("The user is associated to one or more groups.");
                }
                if (errors.indexOf("user-as-manager-not-deletable") >= 0) {
                    reasons.push("The user is the manager of one or more users.");
                    Util.alert("The user cannot be deleted because it either contains direct reports or has group associations. Please remove all associations first.");
                }
                console.log("can't remove reasons", reasons);

                if (reasons.length > 0) {
                    Util.alert(reasons.join("<br/>"), "The user cannot be deleted");
                } else {
                    Util.alert("Failed to delete the user. Please try again later.");
                }
            });
        };
    }

    function UserController(service) {
        var self = this;
        self.deleteIcon = self.deleteIcon || "trash";
        self.guid = Util.genGuid();

        self.uploadImage = function(file) {
            service.uploadUserImage(self.user.id, file).then(function(updatedUser) {
                self.user.imageUrl = updatedUser.imageUrl;
            }, function(err) {
                if (err.indexOf("invalid-image-file") >= 0) {
                    Util.alert("Could not save the image. Invalid file type.", "Invalid image");
                } else {
                    Util.alert("Failed to save the image. Please try again later.");
                }
            });
        };

        self.clearImage = function() {
            var previousImage = self.user.imageUrl;
            self.user.imageUrl = null;
            service.updateUser(self.user).then(null, function(err) {
                console.log(err);
                self.user.imageUrl = previousImage;
                Util.alert("Failed to clear the image for this user. Please try again later.");
            });
        };

        self.createdInfo = function() {
            if (self.user.auditInfo) {
                var info = "Created by ";
                if (self.user.auditInfo.createdBy) {
                    info += self.user.auditInfo.createdBy.fullName();
                } else {
                    info += "UNKNOWN";
                }
                info += " on " + (self.user.auditInfo.createdAt || "UNKNOWN");

                return info;
            }
            return "";
        };

        self.updatedInfo = function() {
            if (self.user.auditInfo) {
                var info = "Last updated by ";
                if (self.user.auditInfo.updatedBy) {
                    info += self.user.auditInfo.updatedBy.fullName();
                } else {
                    info += "UNKNOWN";
                }
                info += " on " + (self.user.auditInfo.updatedAt || "UNKNOWN");

                return info;
            }
            return "";
        };
    }
    
    function UserFormController($rootScope, service, authorizer) {
        var self = this;
        self.managers = self.managers || [];
        self.availableManagers = [];
        self.roles = authorizer.rolesAssignableBy($rootScope.user, $rootScope.user.id === self.user.id);
        if (self.roles.length === 1) {
            self.user.role = self.roles[0].code;
        }
        self.noPreviousPassword = self.user.role === "CONTACT";

        self.handleRoleChange = function() {
            if (self.user.role === "ADMIN" || self.user.role === "PASTOR") {
                self.user.admin = true;
            }
            self.determineAvailableManagers();
        };

        self.determineAvailableManagers = function () {
            var roles = [];
            //noinspection FallThroughInSwitchStatementJS
            switch (self.user.role) {
                case "CONTACT":
                case "GROUP_LEADER":
                    roles.push("DIVISION_LEADER");
                case "DIVISION_LEADER":
                    roles.push("DIVISION_DIRECTOR");
                case "DIVISION_DIRECTOR":
                    roles.push("PASTOR");
            }
            self.availableManagers = self.managers.filter(function (manager) {
                return roles.indexOf(manager.role) >= 0 && manager.id !== self.user.id;
            });

            if (self.availableManagers.filter(function(manager) { return manager.id === self.user.managerId; }).length === 0) {
                self.user.managerId = null;
            }
        };

        self.determineAvailableManagers();

        self.isNew = self.user.id === null || self.user.id === undefined;

        if ((self.isNew || self.startWithChangePassword) && self.user.role !== "CONTACT") {
            self.changePassword = true;
        }

        self.needsManager = function() {
            return self.user.role !== 'PASTOR' && self.user.role !== 'CONTACT' && self.user.role !== 'ADMIN';
        };

        self.save = function (form) {
            if (form.$valid) {
                if (self.user.id === null) {
                    return service.createUser(self.user).then(function (created) {
                        self.user.id = created.id;
                        self.onSave();
                    }, function (errors) {
                        handleServerErrors(form, errors);
                    });
                } else {
                    return service.updateUser(self.user).then(self.onSave, function (errors) {
                        handleServerErrors(form, errors)
                    });
                }
            } else {
                var firstError = $(".has-error:first");
                if (firstError.length > 0) {
                    $('html, body').animate({
                        scrollTop: firstError.offset().top
                    }, 500);
                }
                Util.alert("Please correct errors indicated in red.", 'Info');
                return null;
            }
        };

        function handleServerErrors(form, errors) {
            var expectedError = false;
            if (errors.forEach) {
                errors.forEach(function (err) {
                    if (err === "user-email-not-unique") {
                        form.uEmail.$error.serverValidation = true;
                        form.uEmail.$error.serverError = "already used";
                        expectedError = true;
                    }

                    if (err === "user-role-change-conflict-with-groups") {
                        form.uRole.$error.serverValidation = true;
                        form.uRole.$error.serverError = "This role is not applicable as a leader of one or more groups.";
                        expectedError = true;
                    } else if (err === "user-role-reduction-conflict") {
                        form.uRole.$error.serverValidation = true;
                        form.uRole.$error.serverError = "This role is not applicable for current direct reports.";
                        expectedError = true;
                    }

                    if (err === "facebook-link-invalid") {
                        form.uFacebookLink.$error.serverValidation = true;
                        form.uFacebookLink.$error.serverError = "Not recognized as a valid facebook URL";
                        expectedError = true;
                    }
                });
            }
            if (expectedError) {
                Util.alert("Please correct errors indicated in red.", 'Info');
            } else {
                Util.alert("Failed to save the user. Please try again later.");
            }
        }
    }

    function EditUserController(user, managers, $rootScope, service, changePassword) {
        var self = this;
        self.changePassword = changePassword;
        self.user = user;
        self.managers = managers;

        self.cancel = function() {
            $rootScope.goToUserEditReturnToState();
        };
        
        self.afterSave = function() {
            if (self.isRootUser() && self.user.newPassword !== null && self.user.newPassword !== "") {
                service.login({email: self.user.email, password: self.user.newPassword}).then(function (user) {
                    $rootScope.user= user;
                    $rootScope.goToUserEditReturnToState();
                }, function() {
                    $rootScope.user = null;
                    $rootScope.$state.go("login");
                });
            } else {
                $rootScope.goToUserEditReturnToState();
            }
        };
        
        self.isRootUser = function() {
            return self.user.id === $rootScope.user.id
        };
    }
    
    function UserDetailsController(user, authUser, groups, directReports, $rootScope, service, show) {
        var self = this;
        self.user = user;
        self.groups = groups;
        self.directReports = directReports;

        self.showGroups = show === "groups";
        self.showDirectReports = show === "direct-reports";

        $rootScope.setUserEditReturnToState();
        $rootScope.setGroupEditReturnToState();
        $rootScope.setGroupMemberReturnToState();

        self.isRootUser = function() {
            return self.user.id === authUser.id
        };

        self.deleteGroup = function(group) {
            service.deleteGroup(group).then(function() {
                self.groups.splice(self.groups.indexOf(group), 1);
            });
        };
    }
    
    function NewUserController(managers) {
        var self = this;
        self.user = {};
        self.managers = managers;
    }
})(window.angular);

(function(angular) {
    'use strict';

    angular.module('groups', ['ui.router', 'users', 'ngConstants'])
        .config(["$stateProvider", "partialPath", function ($stateProvider, partialPath) {
            console.log("in config");
            $stateProvider
                .state("groups", {
                    url: "/groups",
                    abstract: true,
                    template: "<ui-view></ui-view>",
                    resolve: {
                        authUser: Util.authenticate
                    }
                })
                .state("groups.index", {
                    url: "",
                    templateUrl: partialPath + "/groups/index.html",
                    controller: ["$rootScope", "graceGroupsService", GroupIndexController],
                    controllerAs: "$ctrl"
                })
                .state("groups.details", {
                    url: "/{id:int}/details?show",
                    templateUrl: partialPath + "/groups/details.html",
                    resolve: {
                        group: ["graceGroupsService", "$stateParams", function(service, $stateParams) {
                            return service.group($stateParams["id"]);
                        }],
                        members: ["graceGroupsService", "$stateParams", function(service, $stateParams) {
                            return service.groupMembers($stateParams["id"]).then(function(users) {
                                return users.sort(compareLastNames);
                            });
                        }],
                        show: ["$stateParams", function($stateParams) {
                            return $stateParams.show;
                        }],
                        meetingLimit: function() {return 5;},
                        meetings: ["graceGroupsService", "$stateParams", "meetingLimit", function(service, $stateParams, meetingLimit) {
                            return service.meetingsByGroup($stateParams["id"], 0, meetingLimit).then(function(meetings) {
                                return meetings;
                            });
                        }],
                        meetingTotalCount: ["graceGroupsService", "$stateParams", function(service, $stateParams) {
                            return service.countMeetingsByGroup($stateParams["id"]).then(function(count) {
                                return count;
                            });
                        }]
                    },
                    controller: ["group", "members", "meetings", "meetingLimit", "meetingTotalCount", "graceGroupsService", "show", "$rootScope", GroupDetailsController],
                    controllerAs: "$ctrl"
                })
                .state("groups.edit", {
                    url: "/{id:int}/edit",
                    templateUrl: partialPath + "/groups/edit.html",
                    resolve: {
                        group: ["graceGroupsService", "$stateParams", function(service, $stateParams) {
                            return service.group($stateParams["id"]);
                        }],
                        leaders: ["graceGroupsService", "authUser", function(service, authUser) {
                            return service.groupLeadersForUser(authUser)      
                        }],
                        divisionLeaders: ["graceGroupsService", function(service) {
                            return service.usersByRole("DIVISION_LEADER");
                        }]
                    },
                    controller: ["$rootScope", "graceGroupsService", "group", "leaders", "divisionLeaders", EditGroupController],
                    controllerAs: "$ctrl"
                })
                .state("groups.new", {
                    url: "/new",
                    templateUrl: partialPath + "/groups/new.html",
                    resolve: {
                        leaders: ["graceGroupsService", "authUser", function (service, authUser) {
                            return service.groupLeadersForUser(authUser);
                        }],
                        divisionLeaders: ["graceGroupsService", function(service) {
                            return service.usersByRole("DIVISION_LEADER");
                        }]
                    },
                    controller: ["$rootScope", "graceGroupsService", "leaders", "divisionLeaders", "authUser", NewGroupController],
                    controllerAs: "$ctrl"
                })
                .state("groups.members", {
                    url: "/{id:int}/members",
                    abstract: true,
                    template: "<ui-view></ui-view>",
                    resolve: {
                        group: ["graceGroupsService", "$stateParams", function(service, $stateParams) {
                            return service.group($stateParams["id"]);
                        }],
                        members: ["graceGroupsService", "$stateParams", function(service, $stateParams) {
                            return service.groupMembers($stateParams["id"]).then(function(users) {
                                return users.sort(compareLastNames);
                            });
                        }]
                    }
                })
                .state("groups.members.view", {
                    url: "",
                    templateUrl: partialPath + "/groups/members.html",
                    controller: ["graceGroupsService", "group", "members", "$rootScope", GroupMembersController],
                    controllerAs: "$ctrl"
                })

                .state("groups.members.select", {
                    url: "/select",
                    templateUrl: partialPath + "/groups/member-select.html",
                    resolve: {
                        limit: function() {return 5;}
                    },
                    controller: ["graceGroupsService", "group", "members", "limit", GroupMemberSelectController],
                    controllerAs: "$ctrl"
                })
                .state("approvals", {
                    url: "/approvals",
                    abstract: true,
                    template: "<ui-view></ui-view>",
                    resolve: {
                        authUser: Util.authenticateAdmin
                    }
                })
                .state("approvals.index", {
                    url: "",
                    templateUrl: partialPath + "/approvals/index.html",
                    resolve: {
                        groups: ["graceGroupsService", function(service) {
                            return service.groupsPendingApproval();
                        }]
                    },
                    controller: ["groups", ApprovalsIndexController],
                    controllerAs: "$ctrl"
                })
                .state("approvals.review", {
                    url: "/{id:int}/review",
                    templateUrl: partialPath + "/approvals/review.html",
                    resolve: {
                        group: ["graceGroupsService", "$stateParams", function(service, $stateParams) {
                            return service.group($stateParams["id"]);
                        }]
                    },
                    controller: ["group", "graceGroupsService", "$state", ApprovalsReviewController],
                    controllerAs: "$ctrl"
                });
        }])
        .component('ggGroup', {
            templateUrl: ["partialPath", function(partialPath) {return partialPath + "/groups/view.html"}],
            bindings: {
                group: "<",
                showEdit: "<",
                showSelect: "<",
                showDelete: "<",
                showDivisionLeader: "<",
                onEdit: "&",
                onMembers: "&",
                onDelete: "&",
                onSelect: "&",
                highlight: "@"
            },
            controller: ["graceGroupsService", "$rootScope", "$element", GroupController]
        })

        .component('graceGroupListing', {
            templateUrl: ["partialPath", function(partialPath) {return partialPath + "/groups/listing.html"}],
            bindings: {
                limit: "<", showSearch: "<", categoryCriteria: "@",
                onEditGroup: "&", onGroupMembers: "&", onSelectGroup: "&"
            },
            controller: ["graceGroupsService", "$rootScope", GroupListingController]
        })

        .component('ggGroupForm', {
            templateUrl: ["partialPath", function(partialPath) {return partialPath + "/groups/groupForm.html"}],
            bindings: { $router: '<', group: "<", leaders: "<", divisionLeaders: "<", onSave: "&", onCancel: "&"},
            controller: [GroupFormController]
        });

    function GroupIndexController($rootScope, graceGroupsService) {
        var self = this;

        $rootScope.setGroupEditReturnToState();
        $rootScope.setGroupMemberReturnToState();

        self.download = function() {
            graceGroupsService.groupExport().then(function(content) {
                Util.downloadContent(content, "text/csv", "groups.csv");
            }, function() {
                Util.alert("Failed to download the groups. Please try again later.");
            });
        }
    }

    function GroupController(service, $rootScope, $element) {
        var self = this;
        self.indicateIfPublic = !!$rootScope.user;

        self.leaderDisplay = function() {
            return leaderDisplay(self.group);
        };

        self.scheduleDisplay = function() {
            return scheduleDisplay(self.group.schedule);
        };

        self.timeDisplay = function() {
            return timeDisplay(self.group.schedule);
        };

        self.ageDisplay = function() {
            return ageDisplay(self.group);
        };

        self.onGraceWestCampus = function() {
            return Util.isGraceWestCampus(self.group.address);
        };

        self.onGraceEastCampus = function() {
            return Util.isGraceEastCampus(self.group.address);
        };

        self.downloadCalendar = function() {
            var serviceFunc = $rootScope.user === null ? service.publishedGroupCalendarExport : service.groupCalendarExport;

            serviceFunc.call(this, self.group.id).then(function(content) {
                Util.downloadContent(content, "text/calendar", "group-calendar.ics");
            }, function() {
                Util.alert("Failed to download the group calendar. Please try again later.");
            });
        };

        self.$onInit = function() {
            $element.find('[data-toggle="tooltip"]').tooltip({trigger: "hover"});

            $element.find('[data-toggle="tooltip"]').on('show.bs.tooltip', function (e) {
                if (Util.isTouchDevice()) e.preventDefault();
            });
        };

        self.showStreetAddress = function() {
            return $rootScope.user || self.onGraceWestCampus() || self.onGraceEastCampus();
        };

        self.groupName = function() {
            return (self.group.namePending && $rootScope.user === null) ? "Group" : self.group.name;
        };
    }

    function GroupListingController(graceGroupsService, $rootScope) {
        var self = this;
        var searchFunction = $rootScope.user ? graceGroupsService.groupSearch : graceGroupsService.publishedGroupSearch;
        var countFunction = $rootScope.user ? graceGroupsService.groupCount : graceGroupsService.publishedGroupCount;
        self.resultLimit = self.limit || 10;
        self.showCriteria = false;
        self.isFiltered = false;

        initSearchCriteria(self.categoryCriteria);

        self.search = function() {
            return doSearch();
        };

        function doSearch(numberOfPages) {
            numberOfPages = (numberOfPages && numberOfPages > 0) ? numberOfPages : 1;
            self.searchCriteria.limit = numberOfPages * self.resultLimit;
            self.searchCriteria.page = 0;
            if (self.searchCriteria.startTimeDate) {
                self.searchCriteria.startTime = moment(self.searchCriteria.startTimeDate).format("HH:mm");
            } else {
                delete self.searchCriteria.startTime;
            }

            if (self.ageType === "ALL") {
                delete self.searchCriteria.age;
            }

            self.loading = true;
            var searchPromise = self.groups = searchFunction.call(this, self.searchCriteria).then(function(groups) {
                self.groups = groups;
                self.isFiltered = criteriaPresent(self.searchCriteria);
                self.searchCriteria.page = numberOfPages - 1;
                self.loading = false;
            });
            countFunction.call(this, self.searchCriteria).then(function(count) {
                self.totalCount = count;
            });

            if (self.showCriteria) {
                self.showCriteria = false;
                $('#search-container').collapse('hide');
            }

            return searchPromise;
        }

        self.showMore = function() {
            self.searchCriteria.page++;
            return searchFunction.call(this, self.searchCriteria).then(function (groups) {
                Array.prototype.push.apply(self.groups, groups);
            });
        };

        self.showMoreCount = function() {
            if (self.groups && self.totalCount) {
                var left = self.totalCount - self.groups.length;
                return left > self.resultLimit ? self.resultLimit : left;
            } else {
                return 0;
            }
        };

        self.clear = function() {
            initSearchCriteria(null);
            self.search();
        };

        self.deleteGroup = function(group) {
            graceGroupsService.deleteGroup(group).then(function() {
                doSearch(self.searchCriteria.page + 1);
            }, function() {
                Util.alert("Failed to delete the group. Please try again later.");
            });
        };

        function criteriaPresent(criteria) {
            var fields = ["category", "keyWord", "dayOfWeek", "startTimeDate", "gender", "status", "age", "childCare", "onCampus"];
            for (var i=0; i<fields.length; i++) {
                if (criteria[fields[i]] && criteria[fields[i]] !== "") {
                    return true;
                }
            }
            return false;
        }

        function initSearchCriteria(categoryCriteria) {
            self.searchCriteria = {
                limit: self.resultLimit,
                page: 0,
                category: categoryCriteria
            };
            self.ageType = "ALL";
        }

        //noinspection JSUnusedGlobalSymbols
        this.$onInit = function() {
            self.search();
        };
    }

    function GroupFormController() {
        var self = this;

        if (!self.group.address) self.group.address = {};
        if (!self.group.schedule) self.group.schedule = {};
        if (!self.group.roomRequest) self.group.roomRequest = {};

        if (self.group.schedule.startTime) {
            self.group.schedule.startTimeDate = moment(self.group.schedule.startTime, "HH:mm").toDate();
        }
        if (self.group.schedule.endTime) {
            self.group.schedule.endTimeDate = moment(self.group.schedule.endTime, "HH:mm").toDate();
        }
        if (self.group.schedule.startDate) {
            self.group.schedule.startDateDate = moment(self.group.schedule.startDate, "YYYY-MM-DD").toDate();
        }
        if (self.group.schedule.endDate) {
            self.group.schedule.endDateDate = moment(self.group.schedule.endDate, "YYYY-MM-DD").toDate();
        }

        self.locationOnCampus = function() {
            return self.group.locationType === 'GRACE_NEED_ROOM' || self.group.locationType === 'GRACE_HAVE_ROOM';
        };

        self.requireScheduleTime = function() {
            return self.group && self.group.schedule.frequency !== 'AS_NEEDED';
        };

        self.charactersRemaining = function(max, val) {
            return max - val.length;
        };

        self.save = function(form) {
            if (form.$valid) {
                if (self.group.locationType === 'GRACE_NEED_ROOM') {
                    self.group.address.room = null;
                }

                formatDateAndTimes();
                if (scheduleConflictsWithGraceClosing(self.group)) {
                    Util.alert("Sorry, the church is closed for meetings after 11pm. Please adjust your schedule.", 'Info');
                    $('html, body').animate({
                        scrollTop: $("#schedule").offset().top
                    }, 500);
                } else if (scheduleConflictsWithCommunionService(self.group)) {
                    Util.alert("Sorry, group meetings cannot occur at the same time as the communion service on first Wednesdays from 7pm to 8pm. Please adjust your schedule.", 'Info');
                    $('html, body').animate({
                        scrollTop: $("#schedule").offset().top
                    }, 500);
                } else {
                    if (self.group.study) {
                        self.group.study = self.group.study.replace(/\n+/g, " ");
                    }
                    return self.onSave(self.group);
                }
            } else {
                var firstError = $(".has-error:first");
                if (firstError.length > 0) {
                    $('html, body').animate({
                        scrollTop: firstError.offset().top
                    }, 500);
                }
                Util.alert("Please correct errors indicated in red.", 'Info');
            }
            return null;
        };

        function formatDateAndTimes() {
            if (self.group.schedule.startTimeDate) {
                self.group.schedule.startTime = moment(self.group.schedule.startTimeDate).format("HH:mm");
            }
            if (self.group.schedule.endTimeDate) {
                self.group.schedule.endTime = moment(self.group.schedule.endTimeDate).format("HH:mm");
            }
            if (self.group.schedule.startDateDate) {
                self.group.schedule.startDate = moment(self.group.schedule.startDateDate).format("YYYY-MM-DD");
            }
            if (self.group.schedule.endDateDate) {
                self.group.schedule.endDate = moment(self.group.schedule.endDateDate).format("YYYY-MM-DD");
            }
        }

        function scheduleConflictsWithCommunionService(group) {
            return group.schedule.dayOfWeek === "WEDNESDAY" &&
                    (group.schedule.frequency === "WEEKLY" || group.schedule.frequency === "EVERY_TWO_WEEKS" || group.schedule.frequency === "BI_MONTHLY_FIRST_THIRD" || group.schedule.frequency === "TRI_MONTHLY" || group.schedule.frequency === "MONTHLY_FIRST") &&
                    group.schedule.startTime && group.schedule.endTime &&
                    moment("2016-10-12T" + group.schedule.startTime).isBefore(moment("2016-10-12T20:00")) &&
                    moment("2016-10-12T" + group.schedule.endTime).isAfter(moment("2016-10-12T19:00"));
        }

        function scheduleConflictsWithGraceClosing(group) {
            return group.locationType !== "OTHER" &&
                moment("2016-10-13T" + group.schedule.endTime).isAfter(moment("2016-10-13T23:00"));
        }

    }

    function GroupDetailsController(group, members, meetings, meetingLimit, meetingTotalCount, service, show, $rootScope) {
        var self = this;
        self.group = group;
        self.members = members;
        self.meetings = meetings;

        self.meetingsPage = 0;

        $rootScope.setGroupEditReturnToState();

        self.showMoreMeetings = function() {
            self.meetingsPage++;
            return service.meetingsByGroup(group.id, self.meetingsPage, meetingLimit).then(function(meetings) {
                Array.prototype.push.apply(self.meetings, meetings);
            });
        };

        self.showMoreMeetingsCount = function() {
            var left = meetingTotalCount - self.meetings.length;
            return left > meetingLimit ? meetingLimit : left;
        };

        self.showMembers = (show === "members");
        if (self.showMembers) {
            $('#members-panel-body').collapse("show");
        }

        self.showReports = (show === "reports");
        if (self.showReports) {
            $('#reports-panel-body').collapse("show");
        }

        self.removeMember = function(user) {
            service.removeGroupMember(self.group.id, user.id).then(function() {
                self.members.splice(self.members.indexOf(user), 1);
            }, function() {
                console.log("failed to remove the member - ", err);
                Util.alert("Failed to remove the member. Please try again later.");
            })
        };

        self.deleteMeetingReport = function(meeting) {
            service.deleteMeeting(meeting).then(function() {
                refreshMeetingReports();
            }, function() {
                Util.alert("Failed to delete the meeting report. Please try again later.");
            });
        };

        function refreshMeetingReports() {
            service.meetingsByGroup(group.id, 0, meetingLimit * (self.meetingsPage + 1)).then(function(meetings) {
                self.meetings = meetings;
            });

            service.countMeetingsByGroup(group.id).then(function(count) {
                meetingTotalCount = count;
            });
        }
    }

    function EditGroupController($rootScope, service, group, leaders, divisionLeaders) {
        var self = this;
        self.group = group;
        self.leaders = leaders;
        self.divisionLeaders = divisionLeaders;

        self.updateGroup = function() {
            return service.updateGroup(self.group).then(function () {
                $rootScope.goToGroupEditReturnToState();
            }, function (err) {
                console.log("failed to update the group: " + err);
                Util.alert("Failed to save the group information. Please try again later.");
            });
        };
    }
    
    function NewGroupController($rootScope, service, leaders, divisionLeaders, authUser) {
        var self = this;
        self.group = {};
        self.leaders = leaders;
        self.divisionLeaders = divisionLeaders;

        if (!$rootScope.authorizer.userCanCreateGroup(authUser)) {
            console.log("unauthorized access");
            $rootScope.$state.go('error');
        } else if (authUser.role === "GROUP_LEADER") {
            self.group.leaderId = authUser.id;
            if (authUser.manager && authUser.manager.role === "DIVISION_LEADER") {
                self.group.divisionLeaderId = authUser.managerId;
            }
        }

        self.createGroup = function() {
            return service.createGroup(self.group).then(function () {
                $rootScope.goToGroupEditReturnToState();
            }, function (err) {
                console.log("failed to create the group: " + err);
                Util.alert("Failed to create the group. Please try again later.");
            });
        };
    }
    
    function GroupMembersController(service, group, members, $rootScope) {
        var self = this;
        self.group = group;
        self.members = members;

        self.removeMember = function(user) {
            service.removeGroupMember(self.group.id, user.id).then(function() {
                self.members.splice(self.members.indexOf(user), 1);
            }, function() {
                console.log("failed to remove the member - ", err);
                Util.alert("Failed to remove the member. Please try again later.");
            })
        };

        self.backToLabel = function() {
            if ($rootScope.groupMemberReturnToState && ($rootScope.groupMemberReturnToState.name === "users.details" || $rootScope.groupMemberReturnToState.name === "users.home")) {
                return "user details";
            } else {
                return "groups";
            }
        }
    }

    function GroupMemberSelectController(service, group, members, limit) {
        var self = this;
        self.newContact = { role: "CONTACT" };
        self.users = [];
        self.totalCount = null;
        self.pageCount = 0;
        self.group = group;

        
        self.nameChanged = function() {
            if ((self.newContact.firstName || "") === "" && (self.newContact.lastName || "") === "") {
                self.users = [];
                self.totalCount = null;
                self.pageCount = 0;
            } else {
                service.usersByName(self.newContact.firstName || "", self.newContact.lastName || "", 0, limit).then(function (users) {
                    self.users = users;
                    self.pageCount = 1;
                });
                service.countUsersByName(self.newContact.firstName || "", self.newContact.lastName || "").then(function (count) {
                    self.totalCount = count;
                });
            }
        };
        
        self.setCreateMode = function(bool) {
            self.createMode = bool;
        };

        self.showMore = function() {
            service.usersByName(self.newContact.firstName || "", self.newContact.lastName || "", self.pageCount++, limit).then(function (users) {
                Array.prototype.push.apply(self.users, users);
            });
        };
        
        self.showMoreCount = function() {
            var left = self.totalCount - self.users.length;
            return left > limit ? limit : left;
        };

        self.isMember = function(user) {
            for (var i = 0; i < members.length; i++) {
                var member = members[i];
                if (member.id === user.id) {
                    return true;
                }
                if (member.lastName.toLocaleLowerCase() > user.lastName.toLocaleLowerCase()) {
                    return false; // since members are already sorted we can stop here
                }
            }
            return false;
        };
        
        self.addMember = function(user) {
            service.addGroupMember(self.group.id, user.id).then(function() {
                members.push(user);
                members.sort(compareLastNames);
                Util.alert("The member has been added to the group","Success!");
            }, function(err) {
                console.log("failed to add the member - ", err);
                Util.alert("Failed to add the member. Please try again later.");
            });
        };
        
        self.saveAndAddMember = function (form) {
            if (form.$valid) {
                service.createUser(self.newContact).then(function (created) {
                    self.newContact.id = created.id;
                    self.addMember(created);
                    self.createMode = false;
                    self.newContact = {};
                }, function (errors) {
                    handleServerErrors(form, errors);
                });
            } else {
                Util.alert("Please correct errors indicated in red.", 'Info');
            }
        };

        function handleServerErrors(form, errors) {
            var expectedError = false;
            if (errors.forEach) {
                errors.forEach(function (err) {
                    if (err === "user-email-not-unique") {
                        form.uEmail.$error.serverValidation = true;
                        form.uEmail.$error.serverError = "already used";
                        expectedError = true;
                    }
                });
            }
            if (expectedError) {
                Util.alert("Please correct errors indicated in red.", 'Info');
            } else {
                Util.alert("Failed to save the user. Please try again later.");
            }
        }

    }
    
    function ApprovalsIndexController(groups) {
        var self = this;
        self.groups = groups;
        self.leaderDisplay = leaderDisplay;
        self.scheduleDisplay = scheduleDisplay;
        self.timeDisplay = timeDisplay;
    }
    
    function ApprovalsReviewController(group, service, $state) {
        var self = this;
        self.group = group;
        self.leaderDisplay = leaderDisplay;
        self.scheduleDisplay = scheduleDisplay;
        self.timeDisplay = timeDisplay;
        self.ageDisplay = ageDisplay;
        
        self.approve = function(form) {
            if (form.$valid) {
                return service.approveGroup(self.group).then(function() {
                    $state.go("approvals.index");
                }, function(err) {
                    console.log("failed to approve the group - ", err);
                    Util.alert("Failed to approve the group. Please try again later.");
                });
            } else {
                var firstError = $(".has-error:first");
                if (firstError.length > 0) {
                    $('html, body').animate({
                        scrollTop: firstError.offset().top
                    }, 500);
                }
                Util.alert("Please correct errors indicated in red.", 'Info');
                return null;
            }
        };
    }
    
    function compareLastNames(u1, u2) {
        return u1.lastName.localeCompare(u2.lastName);
    }
    
    function leaderDisplay(group) {
        var s = group.leader.fullName();
        if (group.secondaryLeader) {
            s = s + " & " + group.secondaryLeader.fullName();
        }
        return s;
    }

    function scheduleDisplay(schedule) {
        if (schedule === null) return "";
        
        switch (schedule.frequency) {
            case "WEEKLY":
                return "Every " + day(schedule);
            case "EVERY_TWO_WEEKS":
                return "Every other " + day(schedule);
            case "BI_MONTHLY_FIRST_THIRD":
                return "Every 1st and 3rd " + day(schedule);
            case "BI_MONTHLY_SECOND_FOURTH":
                return "Every 2nd and 4th " + day(schedule);
            case "TRI_MONTHLY":
                return "Every 1st, 3rd, and 5th " + day(schedule);
            case "MONTHLY_FIRST":
                return "Every 1st " + day(schedule);
            case "MONTHLY_SECOND":
                return "Every 2nd " + day(schedule);
            case "MONTHLY_THIRD":
                return "Every 3rd " + day(schedule);
            case "MONTHLY_FOURTH":
                return "Every 4th " + day(schedule);
            case "AS_NEEDED":
                return day(schedule) + ", as needed";
        }
    }

    function day(schedule) {
        return S(schedule.dayOfWeek).capitalize().s;
    }

    function timeDisplay(schedule) {
        if (schedule === null) return "";
        return moment(schedule.startTime, "HH:mm").format("h:mma") + " to " + moment(schedule.endTime, "HH:mm").format("h:mma");
    }
    
    function ageDisplay(group) {
        if (group.studentMinistry) {
            return "students";
        }

        var min = group.minAge || 18;

        if (min <= 18 && group.maxAge === null) {
            return "all adults";
        } else if (group.maxAge === null) {
            return min + " and older";
        } else {
            return min + " to " + group.maxAge;
        }
    }

})(window.angular);

(function (angular) {
    'use strict';

    angular.module('graceGroupsService', ["ngCookies", "ngConstants", "ngFileUpload"])
        .config(["$httpProvider", function($httpProvider) {
            $httpProvider.defaults.headers.common["X-Requested-With"] = 'XMLHttpRequest';
        }])
        .service('graceGroupsService', ["$http", "$q", "$cookies", "secureCookies", "serviceUrl", "Upload", GraceGroupsService]);

    function GraceGroupsService($http, $q, $cookies, secureCookies, serviceUrl, Upload) {
        var root = serviceUrl;
        var tokenHeader = "ggs-auth-token";
        
        return {
            login: login,
            currentUser: currentUser,
            logout: logout,
            updateUser: updateUser,
            users: users,
            user: user,
            createUser: createUser,
            usersByRole: usersByRole,
            usersByName: usersByName,
            countUsersByName: countUsersByName,
            groupLeadersForUser: groupLeadersForUser,
            managers: managers,
            directReports: directReports,
            deleteUser: deleteUser,
            uploadUserImage: uploadUserImage,

            groups: groups,
            groupExport: groupExport,
            groupsPendingApproval: groupsPendingApproval,
            createGroup: createGroup,
            group: group,
            updateGroup: updateGroup,
            groupMembers: groupMembers,
            addGroupMember: addGroupMember,
            removeGroupMember: removeGroupMember,
            approveGroup: approveGroup,
            groupsForUser: groupsForUser,
            groupSearch: groupSearch,
            groupCount: groupCount,
            publishedGroupSearch: publishedGroupSearch,
            publishedGroupCount: publishedGroupCount,
            deleteGroup: deleteGroup,
            groupCalendarExport: groupCalendarExport,
            publishedGroupCalendarExport: publishedGroupCalendarExport,

            createMeeting: createMeeting,
            updateMeeting: updateMeeting,
            deleteMeeting: deleteMeeting,
            meetingsByGroup: meetingsByGroup,
            countMeetingsByGroup: countMeetingsByGroup,
            meeting: meeting
        };

        //////////////////////////
        // service implementations

        // User implementations

        function login(creds) {
            return $q(function (resolve, reject) {
                $http.post(path("/users/login"), creds, httpOptions()).then(function (response) {
                    $cookies.put(tokenHeader, response.data.token, {secure: secureCookies});
                    supplementUser(response.data.user);
                    resolve(response.data.user);
                }, function (response) {
                    var err = response.status < 500 && response.status > 399 ? "invalid-login" : "server-error";
                    reject(err);
                });
            });
        }

        function currentUser() {
            return $q(function(resolve, reject) {
                $http.get(path("/users/current"), httpOptions()).then(function (response) {
                    supplementUser(response.data);
                    resolve(response.data);
                }, function (response) {
                    console.log("current user error", response);
                    var err = response.status === 401 ? 'no-auth' : 'server-error';
                    reject(err);
                });
            });
        }

        function logout() {
            $cookies.remove(tokenHeader);
        }
        
        function updateUser(user) {
            return $q(function(resolve, reject) {
                $http.put(path("/users", user.id), user, httpOptions()).then(function() {
                    resolve();
                }, function (response) {
                    reject(buildPostErrors(response));
                });
            });
        }
        
        function createUser(user) {
            return $q(function(resolve, reject) {
                $http.post(path("/users"), user, httpOptions()).then(function(response) {
                    supplementUser(response.data);
                    resolve(response.data);
                }, function (response) {
                    reject(buildPostErrors(response));
                });
            });
        }
        
        function users() {
            return $q(function(resolve, reject) {
                $http.get(path("/users"), httpOptions()).then(function (response) {
                    response.data.forEach(function(user) {
                        supplementUser(user);
                    });
                    resolve(response.data);
                }, function () {
                    reject("server-error");
                });
            });
        }

        function user(userId) {
            return $q(function(resolve, reject) {
                $http.get(path("/users", userId), httpOptions()).then(function (response) {
                    supplementUser(response.data);
                    resolve(response.data);
                }, function (response) {
                    var err = response.status < 500 ? "user-not-found" : "server-error";
                    reject(err);
                });
            });
        }
        
        function usersByRole(role) {
            return $q(function(resolve, reject) {
                $http.get(path("/users/by-role"), httpOptions({role: role})).then(function (response) {
                    response.data.forEach(function(user) {
                        supplementUser(user);
                    });
                    resolve(response.data);
                }, function (err) {
                    console.log(err);
                    reject("server-error");
                });
            });
        }
        
        function usersByName(firstName, lastName, page, limit) {
            return $q(function(resolve, reject) {
                $http.get(path("/users/by-name"), httpOptions({firstName: firstName, lastName: lastName, page: page, limit: limit})).then(function (response) {
                    response.data.forEach(function(user) {
                        supplementUser(user);
                    });
                    resolve(response.data);
                }, function () {
                    reject("server-error");
                });
            });
        }
        
        function countUsersByName(firstName, lastName) {
            return $q(function(resolve, reject) {
                $http.get(path("/users/count/by-name"), httpOptions({firstName: firstName, lastName: lastName})).then(function (response) {
                    resolve(response.data);
                }, function () {
                    reject("server-error");
                });
            });
        }

        function groupLeadersForUser(user) {
            return $q(function(resolve, reject) {
                $http.get(path("/users", user.id, "group-leaders"), httpOptions()).then(function (response) {
                    response.data.forEach(function(user) {
                        supplementUser(user);
                    });
                    resolve(response.data);
                }, function () {
                    reject("server-error");
                });
            });
        }

        function managers() {
            return $q(function(resolve, reject) {
                $http.get(path("/users/managers"), httpOptions()).then(function (response) {
                    response.data.forEach(function(user) {
                        supplementUser(user);
                    });
                    resolve(response.data);
                }, function () {
                    reject("server-error");
                });
            });
        }
        
        function directReports(userId) {
            return $q(function(resolve, reject) {
                $http.get(path("/users", userId, "direct-reports"), httpOptions()).then(function (response) {
                    response.data.forEach(function(user) {
                        supplementUser(user);
                    });
                    resolve(response.data);
                }, function () {
                    reject("server-error");
                });
            });
        }

        function deleteUser(user) {
            return $q(function(resolve, reject) {
                $http.delete(path("/users", user.id), httpOptions()).then(function() {
                    resolve();
                }, function (response) {
                    reject(buildPostErrors(response));
                });
            });
        }

        function uploadUserImage(userId, imageFile) {
            var authToken = $cookies.get(tokenHeader);
            return $q(function(resolve, reject) {
                Upload.upload({
                    url: path("/users", userId, "image"),
                    data: {file: imageFile},
                    headers: {'Authorization': 'Bearer ' + authToken},
                    method: "POST"
                }).then(function(resp) {
                    console.log(resp.data);
                    supplementUser(resp.data);
                    resolve(resp.data);
                }, function (err) {
                    reject(buildPostErrors(err));
                });
            });
        }

        // Group implementations

        function groups() {
            return $q(function(resolve, reject) {
                $http.get(path("/groups"), httpOptions()).then(function (response) {
                    response.data.forEach(function(group) {
                        supplementGroup(group);
                    });
                    resolve(response.data);
                }, function () {
                    reject("server-error");
                });
            });
        }

        function groupExport() {
            return $q(function(resolve, reject) {
                $http.get(path("/groups/export"), httpOptions()).then(function (response) {
                    resolve(response.data);
                }, function () {
                    reject("server-error");
                });
            });
        }

        function groupsPendingApproval() {
            return $q(function(resolve, reject) {
                $http.get(path("/groups/pending-approval"), httpOptions()).then(function (response) {
                    response.data.forEach(function(group) {
                        supplementGroup(group);
                    });
                    resolve(response.data);
                }, function () {
                    reject("server-error");
                });
            });
        }

        function createGroup(group) {
            return $q(function(resolve, reject) {
                $http.post(path("/groups"), group, httpOptions()).then(function() {
                    resolve();
                }, function (response) {
                    reject(buildPostErrors(response));
                });
            });
        }
        
        function group(groupId) {
            return $q(function(resolve, reject) {
                $http.get(path("/groups", groupId), httpOptions()).then(function (response) {
                    supplementGroup(response.data);
                    resolve(response.data);
                }, function (response) {
                    var err = response.status < 500 ? "group-not-found" : "server-error";
                    reject(err);
                });
            });
        }
        
        function updateGroup(group) {
            return $q(function(resolve, reject) {
                $http.put(path("/groups", group.id), group, httpOptions()).then(function() {
                    resolve();
                }, function (response) {
                    reject(buildPostErrors(response));
                });
            });
        }

        function groupMembers(groupId) {
            return $q(function(resolve, reject) {
                $http.get(path("/groups", groupId, "members"), httpOptions()).then(function (response) {
                    response.data.forEach(function(user) {
                        supplementUser(user);
                    });
                    resolve(response.data);
                }, function (response) {
                    var err = response.status < 500 ? "group-not-found" : "server-error";
                    reject(err);
                });
            });
        }

        function addGroupMember(groupId, userId) {
            return $q(function(resolve, reject) {
                $http.put(path("/groups", groupId, "add-member/" + userId), null, httpOptions()).then(function() {
                    resolve();
                }, function (response) {
                    var err = response.status < 500 ? "bad-data" : "server-error";
                    reject(err);
                });
            });
        }
        
        function removeGroupMember(groupId, userId) {
            return $q(function(resolve, reject) {
                $http.put(path("/groups", groupId, "remove-member/" + userId), null, httpOptions()).then(function() {
                    resolve();
                }, function (response) {
                    var err = response.status < 500 ? "bad-data" : "server-error";
                    reject(err);
                });
            });
        }
        
        function approveGroup(group) {
            return $q(function(resolve, reject) {
                $http.put(path("/groups", group.id, "approve"), group, httpOptions()).then(function() {
                    resolve();
                }, function () {
                    reject("server-error");
                });
            });
        }

        function groupsForUser(userId) {
            return $q(function(resolve, reject) {
                $http.get(path("/groups/by-user"), httpOptions({userId: userId})).then(function (response) {
                    response.data.forEach(function(group) {
                        supplementGroup(group);
                    });
                    resolve(response.data);
                }, function () {
                    reject("server-error");
                });
            });
        }

        function groupSearch(criteria) {
            return $q(function(resolve, reject) {
                $http.get(path("/groups/search"), httpOptions(criteria)).then(function (response) {
                    console.log(response);
                    response.data.forEach(function(group) {
                        supplementGroup(group);
                    });
                    resolve(response.data);
                }, function () {
                    reject("server-error");
                });
            });
        }

        function groupCount(criteria) {
            return $q(function(resolve, reject) {
                $http.get(path("/groups/count"), httpOptions(criteria)).then(function (response) {
                    resolve(response.data);
                }, function () {
                    reject("server-error");
                });
            });
        }

        function publishedGroupSearch(criteria) {
            return $q(function(resolve, reject) {
                $http.get(path("/groups/published/search"), httpOptions(criteria)).then(function (response) {
                    console.log(response);
                    response.data.forEach(function(group) {
                        supplementGroup(group);
                    });
                    resolve(response.data);
                }, function () {
                    reject("server-error");
                });
            });
        }

        function publishedGroupCount(criteria) {
            return $q(function(resolve, reject) {
                $http.get(path("/groups/published/count"), httpOptions(criteria)).then(function (response) {
                    resolve(response.data);
                }, function () {
                    reject("server-error");
                });
            });
        }

        function deleteGroup(group) {
            return $q(function(resolve, reject) {
                $http.delete(path("/groups", group.id), httpOptions()).then(function() {
                    resolve();
                }, function (response) {
                    reject(buildPostErrors(response));
                });
            });
        }

        function groupCalendarExport(groupId) {
            return $q(function(resolve, reject) {
                $http.get(path("/groups", groupId, "calendar-export"), httpOptions()).then(function (response) {
                    resolve(response.data);
                }, function () {
                    reject("server-error");
                });
            });
        }

        function publishedGroupCalendarExport(groupId) {
            return $q(function(resolve, reject) {
                $http.get(path("/groups", groupId, "published/calendar-export"), httpOptions()).then(function (response) {
                    resolve(response.data);
                }, function () {
                    reject("server-error");
                });
            });
        }

        //////////////////////////
        // meeting implementations

        function createMeeting(meeting) {
            return $q(function(resolve, reject) {
                $http.post(path("/meetings"), meeting, httpOptions()).then(function() {
                    resolve();
                }, function (response) {
                    reject(buildPostErrors(response));
                });
            });
        }

        function updateMeeting(meeting) {
            return $q(function(resolve, reject) {
                $http.put(path("/meetings", meeting.id), meeting, httpOptions()).then(function() {
                    resolve();
                }, function (response) {
                    reject(buildPostErrors(response));
                });
            });
        }

        function deleteMeeting(meeting) {
            return $q(function(resolve, reject) {
                $http.delete(path("/meetings", meeting.id), httpOptions()).then(function() {
                    resolve();
                }, function (response) {
                    reject(buildPostErrors(response));
                });
            });
        }

        function meetingsByGroup(groupId, page, limit) {
            return $q(function(resolve, reject) {
                $http.get(path("/meetings/by-group", groupId), httpOptions({page: page, limit: limit})).then(function (response) {
                    response.data.forEach(function(meeting) {
                        supplementMeeting(meeting);
                    });
                    resolve(response.data);
                }, function () {
                    reject("server-error");
                });
            });
        }

        function countMeetingsByGroup(groupId) {
            return $q(function(resolve, reject) {
                $http.get(path("/meetings/count/by-group", groupId), httpOptions()).then(function (response) {
                    resolve(response.data);
                }, function () {
                    reject("server-error");
                });
            });
        }

        function meeting(id) {
            return $q(function(resolve, reject) {
                $http.get(path("/meetings", id), httpOptions()).then(function (response) {
                    supplementMeeting(response.data);
                    resolve(response.data);
                }, function (response) {
                    var err = response.status < 500 ? "meeting-not-found" : "server-error";
                    reject(err);
                });
            });
        }

        /////////////////
        // Helper methods

        function path(path, resourceId, pathAfterId) {
            var result = root + path;
            if (resourceId) {
                result = result + "/" + resourceId;
            }
            if (pathAfterId) {
                result = result + "/" + pathAfterId;
            }
            return result;
        }

        function httpOptions(params) {
            var opts = {withCredentials: true};
            if (params) {
                opts["params"] = params;
            }

            var authToken = $cookies.get(tokenHeader);
            if (authToken) {
                opts.headers = {Authorization: "Bearer " + authToken};
            }
            return opts;
        }
        
        function supplementUser(user) {
            user.shortName = function() {
                return S(user.firstName).capitalize().s + " " + S(user.lastName.substring(0, 1)).capitalize() + ".";
            };

            setFullNameFunction(user);

            user.roleLabel = function() {
                return S(user.role).humanize().s;
            };

            supplementAuditInfo(user.auditInfo);

            user.facebookLinkFull = function() {
                if (user.facebookLink) {
                    return Util.externalUrl(user.facebookLink, true);
                } else {
                    return null;
                }
            };

            user.facebookLinkShort = function() {
                if (user.facebookLink) {
                    return user.facebookLink.replace(/http:\/\/|https:\/\//, "").replace("www.", "");
                } else {
                    return null;
                }
            };
        }

        function supplementAuditInfo(info) {
            if (info) {
                if (info.createdBy) {
                    setFullNameFunction(info.createdBy);
                }
                if (info.updatedBy) {
                    setFullNameFunction(info.updatedBy);
                }
            }
        }

        function setFullNameFunction(user) {
            user.fullName = function() {
                return S(user.firstName).capitalize().s + " " + S(user.lastName).capitalize().s;
            };
        }
        
        function supplementGroup(group) {
            supplementUser(group.leader);
            if (group.secondaryLeader) {
                supplementUser(group.secondaryLeader);
            }
            if (group.divisionLeader) {
                supplementUser(group.divisionLeader);
            }
            group.isFull = function() {
                return this.capacity !== null && this.memberIds.length >= this.capacity;
            };

            supplementAuditInfo(group.auditInfo);
        }

        function supplementMeeting(meeting) {
            meeting.memberCount = function(members) {
                return this.attendance.filter(function(a) {
                    return members.filter((function(m) { return m.id === a.userId; })).length > 0;
                }).length;
            };
            meeting.guestCount = function(members) {
                return this.attendance.filter(function(a) {
                    return members.filter((function(m) { return m.id === a.userId; })).length === 0;
                }).length;
            };

            supplementAuditInfo(meeting.auditInfo);
        }

        function buildPostErrors(response) {
            return response.status < 500 && response.status > 399 ? response.data : ["server-error"];
        }
    }
})(window.angular);
(function (angular) {
    'use strict';

    angular.module('authorizer', []).service('authorizer', [Authorizer]);

    function Authorizer() {
        var roles = [
            {code: "ADMIN", label: "Admin"},
            {code: "PASTOR", label: "Pastor"},
            {code: "DIVISION_DIRECTOR", label: "Division Director"},
            {code: "DIVISION_LEADER", label: "Division Leader"},
            {code: "GROUP_LEADER", label: "Group Leader"},
            {code: "CONTACT", label: "Contact"}
        ];

        return {
            roles: allRoles,
            rolesAssignableBy: rolesAssignableBy,
            userCanEditUser: userCanEditUser,
            userCanDeleteUser: userCanDeleteUser,
            userCanChangeManagerOf: userCanChangeManagerOf,
            userCanChangeGroupLeader: userCanChangeGroupLeader,
            userCanEditGroup: userCanEditGroup,
            userCanCreateGroup: userCanCreateGroup,
            userCanSeeAuditInfo: userCanSeeAuditInfo,
            isUserManagerOf: isUserManagerOf,
            userCanDeleteGroup: userCanDeleteGroup,
            groupPrivileges: groupPrivileges,
            groupPrivilegesString: groupPrivilegesString,
            canDownloadGroups: canDownloadGroups,
            canEditMeetingForGroup: canEditMeetingForGroup
        };

        //////////////////////////
        // service implementations

        function allRoles() {
            return roles.slice();
        }

        function rolesAssignableBy(user, selfUpdate) {
            selfUpdate = selfUpdate || false;

            if (user.role === "PASTOR" || user.admin) {
                return roles.slice();
            }

            for (var i = 0; i < roles.length - 1; i++) {
                if (roles[i].code === user.role) {
                    return roles.slice(selfUpdate ? i : i + 1);
                }
            }

            return [{code: "CONTACT", label: "Contact"}];
        }
        
        function userCanEditUser(user, userToEdit) {
            if (user === null) {
                return false;
            }
            
            if (user.admin || user.role === "PASTOR" || userToEdit.role === "CONTACT" || user.id === userToEdit.id) {
                return true;
            }

            return isUserManagerOf(user, userToEdit);
        }

        function userCanDeleteUser(user, userToDelete) {
            if (user === null) {
                return false;
            }

            if (userToDelete.role === 'CONTACT') {
                return isAdminOrPastor(user)
            } else {
                return user.id !== userToDelete.id && userCanEditUser(user, userToDelete);
            }
        }
        
        function userCanChangeManagerOf(user, userToChangeManagerOf) {
            if (user === null) return false;
            return user.admin || userToChangeManagerOf.id === null || userToChangeManagerOf.manager === null || (userCanEditUser(user, userToChangeManagerOf) && user.id !== userToChangeManagerOf.id);
        }
        
        function userCanChangeGroupLeader(user) {
            if (user === null) return false;
            return user.admin || (user.role !== "GROUP_LEADER" && user.role !== "CONTACT");
        }

        function userCanEditGroup(user, group) {
            if (user === null) {
                return false;
            }

            var isAdminOrPastor = user.admin || user.role === "PASTOR";
            var isLeader = user.id === group.leaderId;
            var isSecondaryLeader = user.id === group.secondaryLeaderId;
            var isManager = isUserManagerOf(user, group.leader);

            return isAdminOrPastor || isLeader || isSecondaryLeader || isManager;
        }

        function userCanCreateGroup(user) {
            return user !== null;
        }

        function userCanSeeAuditInfo(user) {
            return isAdminOrPastor(user);
        }

        function isUserManagerOf(user, otherUser) {
            var manager = otherUser.manager;
            var count = 0;
            while (manager !== null && count++ < roles.length-1) {
                if (manager.id === user.id) {
                    return true;
                }
                manager = manager.manager;
            }
            return false;
        }

        function userCanDeleteGroup(user, group) {
            return userCanEditGroup(user, group);
        }

        function groupPrivileges(user, group) {
            var privileges = [];
            if (userCanEditGroup(user, group)) {
                privileges.push("edit");
            }
            if (userCanDeleteGroup(user, group)) {
                privileges.push("delete");
            }
            return privileges;
        }

        function groupPrivilegesString(user, group) {
            return groupPrivileges(user, group).join(" ");
        }

        function canDownloadGroups(user) {
            return isAdminOrPastor(user);
        }

        function canEditMeetingForGroup(user, group) {
            if (user === null) return false;

            var isLeader = group.leaderId === user.id || group.secondaryLeaderId === user.id;
            var isDivisionLeader = group.divisionLeaderId === user.id;
            return isAdminOrPastor(user) || isLeader || isDivisionLeader;
        }

        function isAdminOrPastor(user) {
            return user && (user.admin || user.role === "PASTOR");
        }
    }
    
})(window.angular);

